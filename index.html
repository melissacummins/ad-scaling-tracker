<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ad Scaling Tracker Dashboard</title>
    
    <!-- Firebase SDKs - Using compat version to avoid CSP issues -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-compat.js"></script>
    
    <style>
        /* Books Analysis View */
.book-analysis-card {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    margin-bottom: 25px;
    overflow: hidden;
}

.book-card-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px 25px;
    cursor: pointer;
    transition: all 0.3s;
}

.book-card-header:hover {
    background: linear-gradient(135deg, #5a67d8 0%, #6a3f8f 100%);
}

.book-card-title {
    margin-bottom: 15px;
}

.book-card-stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
}

.book-stat {
    text-align: center;
    background: rgba(255,255,255,0.15);
    padding: 12px;
    border-radius: 8px;
}

.book-stat-value {
    font-size: 22px;
    font-weight: bold;
    margin-bottom: 5px;
}

.book-stat-label {
    font-size: 12px;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.book-card-content {
    padding: 20px 25px;
}

.hooks-analysis-table {
    width: 100%;
    border-collapse: collapse;
}

.hooks-analysis-table th {
    background: #f8f9fa;
    padding: 12px;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid #e2e8f0;
}

.hooks-analysis-table td {
    padding: 12px;
    border-bottom: 1px solid #e2e8f0;
}

.hook-row {
    cursor: pointer;
    transition: background 0.2s;
}

.hook-row:hover {
    background: #f8f9fa;
}
        
        .book-header-row {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.book-header-row:hover {
    background: linear-gradient(135deg, #5a67d8 0%, #6a3f8f 100%);
}

.book-group-content {
    transition: all 0.3s;
}
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }

        .container {
            width: 100%;
            margin: 0;
            background: white;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            flex: 1;
            text-align: center;
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .controls-row-2 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 30px;
            padding: 0 20px 20px;
            background: #f8f9fa;
            border-radius: 0 0 10px 10px;
            margin-top: -30px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .book-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .book-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .add-book-form {
            display: none;
            margin-top: 10px;
        }

        .add-book-form.active {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .add-book-form input {
            flex: 1;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            margin: 2px;
            white-space: nowrap;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-xs {
            padding: 4px 8px;
            font-size: 11px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        /* FIXED TABLE STYLES - Single table with sticky headers */
        .table-wrapper {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            background: white;
            margin-top: 20px;
            /* Set a maximum height to enable scrolling */
            max-height: 70vh;
            overflow-y: auto;
            position: relative;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            background: white;
            table-layout: fixed;
        }

        .data-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #f8f9fa;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .data-table th {
            padding: 12px 4px;
            text-align: center;
            border-bottom: 3px solid #667eea !important;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            background: #f8f9fa !important;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .data-table td {
            padding: 12px 4px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Allow Creative ID column to wrap - both header and data */
        .data-table th:nth-child(12),
        .data-table td:nth-child(12) {
            white-space: normal !important;
            word-break: break-all !important;
            overflow: visible !important;
            text-overflow: unset !important;
            word-wrap: break-word !important;
            hyphens: auto !important;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        /* Left align specific columns */
        .data-table th:nth-child(1),
        .data-table td:nth-child(1), /* Book */
        .data-table th:nth-child(2),
        .data-table td:nth-child(2)  /* Hook */
        {
            text-align: left;
            white-space: normal; /* Allow wrapping for book and hook names */
        }

        /* Set specific column widths - optimized for better spacing (removed Next Action column) */
        .data-table th:nth-child(1),
        .data-table td:nth-child(1) { width: 6%; }   /* Book */
        .data-table th:nth-child(2),
        .data-table td:nth-child(2) { width: 9%; }   /* Hook */
        .data-table th:nth-child(3),
        .data-table td:nth-child(3) { width: 7%; }   /* Test Month/Year */
        .data-table th:nth-child(4),
        .data-table td:nth-child(4) { width: 6%; }   /* Total Spend */
        .data-table th:nth-child(5),
        .data-table td:nth-child(5) { width: 6%; }   /* Total Revenue */
        .data-table th:nth-child(6),
        .data-table td:nth-child(6) { width: 6%; }   /* Purchases */
        .data-table th:nth-child(7),
        .data-table td:nth-child(7) { width: 5%; }   /* Overall ROAS */
        /* Allow text wrapping in Performance Level column */
        .data-table th:nth-child(8),
        .data-table td:nth-child(8) { 
            width: 8%; 
            white-space: normal !important; /* Allow wrapping for performance badges */
        }
        .data-table th:nth-child(9),
        .data-table td:nth-child(9) { width: 12%; }  /* ROAS Milestones */
        .data-table th:nth-child(10),
        .data-table td:nth-child(10) { width: 8%; }  /* Momentum Score */
        .data-table th:nth-child(11),
        .data-table td:nth-child(11) { 
            width: 12%; 
            white-space: normal !important;
            word-break: break-all;
        } /* Creative ID */
        .data-table th:nth-child(12),
        .data-table td:nth-child(12) { width: 10%; } /* Actions */

        /* Creative ID Tracker table specific column widths */
        .creatives-table th:nth-child(1),
        .creatives-table td:nth-child(1) { width: 20%; } /* Creative ID */
        .creatives-table th:nth-child(2),
        .creatives-table td:nth-child(2) { width: 12%; } /* Total Spend */
        .creatives-table th:nth-child(3),
        .creatives-table td:nth-child(3) { width: 12%; } /* Total Revenue */
        .creatives-table th:nth-child(4),
        .creatives-table td:nth-child(4) { width: 10%; } /* Overall ROAS */
        .creatives-table th:nth-child(5),
        .creatives-table td:nth-child(5) { width: 8%; }  /* Hooks Used */
        .creatives-table th:nth-child(6),
        .creatives-table td:nth-child(6) { width: 20%; } /* Best Hook (ROAS) */
        .creatives-table th:nth-child(7),
        .creatives-table td:nth-child(7) { width: 15%; } /* Notes */
        .creatives-table th:nth-child(8),
        .creatives-table td:nth-child(8) { width: 8%; }  /* Actions */

        /* Books Management table specific column widths */
        .books-table th:nth-child(1),
        .books-table td:nth-child(1) { width: 20%; } /* Book Title */
        .books-table th:nth-child(2),
        .books-table td:nth-child(2) { width: 10%; } /* Total Hooks */
        .books-table th:nth-child(3),
        .books-table td:nth-child(3) { width: 12%; } /* Total Spend */
        .books-table th:nth-child(4),
        .books-table td:nth-child(4) { width: 12%; } /* Total Revenue */
        .books-table th:nth-child(5),
        .books-table td:nth-child(5) { width: 10%; } /* Average ROAS */
        .books-table th:nth-child(6),
        .books-table td:nth-child(6) { width: 25%; } /* Best Performing Hook */
        .books-table th:nth-child(7),
        .books-table td:nth-child(7) { width: 11%; } /* Actions */

        /* Allow text wrapping in specific columns for these tables */
        .creatives-table th:nth-child(1),
        .creatives-table td:nth-child(1),
        .creatives-table th:nth-child(6),
        .creatives-table td:nth-child(6),
        .books-table th:nth-child(1),
        .books-table td:nth-child(1),
        .books-table th:nth-child(6),
        .books-table td:nth-child(6) {
            white-space: normal !important;
            word-wrap: break-word !important;
        }

        .performance-badge {
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            white-space: normal; /* Allow text wrapping */
            line-height: 1.2;
            min-height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .not-tested { background: #6c757d; color: white; }
        .testing-incomplete { background: #ffc107; color: #212529; }
        .testing { background: #17a2b8; color: white; }
        .validated { background: #28a745; color: white; }
        .early-scale { background: #007bff; color: white; }
        .proven-scale { background: #6f42c1; color: white; }
        .mature-scale { background: #fd7e14; color: white; }

        .momentum-score {
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }

        .momentum-accelerating { background: #4caf50; color: white; } /* üöÄ >105% */
        .momentum-stable { background: #28a745; color: white; } /* üü¢ 95-105% */
        .momentum-declining { background: #ffc107; color: #212529; } /* üü° 85-95% */
        .momentum-degrading { background: #dc3545; color: white; } /* üî¥ <85% */
        .momentum-na { background: #6c757d; color: white; } /* ‚ö´ N/A */

        .scale-efficiency {
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }

        .scales-well { background: #28a745; color: white; }
        .scales-ok { background: #ffc107; color: #212529; }
        .doesnt-scale { background: #dc3545; color: white; }

        .next-action {
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            white-space: normal !important;
            line-height: 1.2;
            min-height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-scale-now { background: #28a745; color: white; }
        .action-continue { background: #007bff; color: white; }
        .action-test-creative { background: #ffc107; color: #212529; }
        .action-scale-further { background: #007bff; color: white; }
        .action-cap-here { background: #6c757d; color: white; }
        .action-phase-out { background: #fd7e14; color: white; }
        .action-kill { background: #dc3545; color: white; }
        .action-scale-optimize { background: #6f42c1; color: white; }
        .action-na { background: #e9ecef; color: #6c757d; }

        .milestone-display {
            text-align: center;
            min-width: 120px;
        }

        .current-milestone {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .milestone-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 11px;
            text-decoration: underline;
            padding: 0;
        }

        .milestone-toggle:hover {
            color: #5a67d8;
        }

        .milestone-history {
            display: none;
            margin-top: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 11px;
        }

        .milestone-history.active {
            display: block;
        }

        .milestone-item {
            margin: 2px 0;
            color: #666;
        }

        .hook-group {
            background: #f8f9fa;
        }

        .hook-group.expanded .creative-details {
            display: table-row;
        }

        .creative-details {
            display: none;
            background: #f0f8ff;
            font-size: 13px;
        }

        .creative-details td {
            padding: 8px 12px;
            border-left: 4px solid #667eea;
        }

        .expand-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .expand-toggle:hover {
            background: #e9ecef;
        }

        .creative-count {
            font-size: 12px;
            color: #666;
            margin-left: 5px;
        }

        .best-creative {
            background: #d4edda;
            border-left-color: #28a745 !important;
        }

        .creative-notes {
            max-width: 200px;
            resize: vertical;
        }

        /* ROAS color coding for Creative ID Tracker */
        .roas-poor {
            color: #dc3545;
            font-weight: bold;
        }

        .roas-okay {
            color: #ffc107;
            font-weight: bold;
        }

        .roas-good {
            color: #28a745;
            font-weight: bold;
        }

        .edit-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .edit-form.active {
            display: block;
        }

        .import-export {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .file-upload input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-upload-label {
            display: inline-block;
            padding: 12px 24px;
            background: #6c757d;
            color: white;
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s;
            font-weight: 600;
            cursor: pointer;
        }

        .file-upload-label:hover {
            background: #5a6268;
        }
        
        .login-screen {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .login-screen .header {
            margin-bottom: 0;
        }

        @media (max-width: 1200px) {
            .controls {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .controls-row-2 {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
        }

        @media (max-width: 768px) {
            .controls,
            .controls-row-2 {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .data-table {
                font-size: 12px;
            }
            
            .data-table th,
            .data-table td {
                padding: 8px 4px;
            }

            .tabs {
                flex-direction: column;
            }

            .import-export {
                flex-direction: column;
                align-items: stretch;
            }

            .tab-content {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Screen (shown when not signed in) -->
        <div id="loginScreen" class="login-screen">
            <div class="header">
                <h1>üìä Ad Scaling Tracker</h1>
                <p>Track hooks, campaigns, ROAS, and scale performance across all your ad campaigns</p>
            </div>
            <div style="text-align: center; padding: 50px;">
                <h2 style="margin-bottom: 30px; color: #333;">Sign in to access your data</h2>
                <p style="margin-bottom: 30px; color: #666; max-width: 500px; margin-left: auto; margin-right: auto;">
                    Your ad scaling data is securely stored in the cloud and synced across all your devices. 
                    Sign in with your Google account to get started.
                </p>
                <button id="loginButton" class="btn btn-primary" style="font-size: 18px; padding: 15px 30px;">
                    üîê Sign in with Google
                </button>
                <div id="loginStatus" style="margin-top: 20px; color: #666;"></div>
            </div>
        </div>

        <!-- Main App (shown when signed in) -->
        <div id="mainApp" style="display: none;">
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;">
                <div>
                    <h1>üìä Ad Scaling Tracker</h1>
                    <p>Track hooks, campaigns, ROAS, and scale performance across all your ad campaigns</p>
                </div>
                <div id="authSection" style="text-align: right; min-width: 200px;">
                    <div id="signedInView">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <img id="userPhoto" style="width: 40px; height: 40px; border-radius: 50%;" alt="User photo" />
                            <div id="userName" style="font-weight: bold;"></div>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button id="signOutButton" class="btn btn-secondary btn-sm">üö™ Sign Out</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tabs">
    <button class="tab active" onclick="switchTab('hooks')">üéØ Hooks Tracker</button>
    <button class="tab" onclick="switchTab('books')">üìö Books Management</button>
    <button class="tab" onclick="switchTab('creatives')">üé® Creative ID Tracker</button>
    <button class="tab" onclick="switchTab('archive')">üì¶ Archive</button>
</div>

        <!-- Hooks Tab -->
        <div id="hooksTab" class="tab-content active">
            <!-- Import/Export Controls -->
            <div class="import-export">
    <button class="btn btn-secondary" onclick="exportData()">üì• Export CSV</button>
    <div class="file-upload">
        <input type="file" id="csvImport" accept=".csv,.xlsx,.xls" onchange="importData(event)">
        <label for="csvImport" class="file-upload-label">üì§ Import CSV/Excel</label>
    </div>
    <button class="btn btn-warning" onclick="clearAllData()">‚å´ Clear All Data</button>
    <button class="btn btn-info" onclick="runMilestoneMigration()">üîß Fix Missing Milestones</button>
</div>

            <!-- Edit Form (Hidden by default) -->
            <div id="editForm" class="edit-form">
                <h3>Edit Hook Entry</h3>
                <input type="hidden" id="editIndex">
                <div class="controls">
                    <div class="form-group">
                        <div class="book-header">
                            <label for="editBookSelect">Book</label>
                        </div>
                        <select id="editBookSelect">
                            <option value="">Select Book...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="editHookName">Hook Name/Description</label>
                        <textarea id="editHookName" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="editTestDate">Test Month/Year</label>
                        <input type="text" id="editTestDate" placeholder="MM/YYYY (e.g., 03/2024)">
                    </div>
                    <div class="form-group">
                        <label for="editTotalSpend">Total Spend ($)</label>
                        <input type="number" id="editTotalSpend" step="0.01" min="0">
                    </div>
                </div>
                <div class="controls-row-2">
                    <div class="form-group">
                        <label for="editTotalRevenue">Total Revenue ($)</label>
                        <input type="number" id="editTotalRevenue" step="0.01" min="0">
                    </div>
                    <div class="form-group">
                        <label for="editPurchases">Number of Purchases</label>
                        <input type="number" id="editPurchases" min="0">
                    </div>
                    <div class="form-group">
                        <label for="editCreativesCount">Creatives Tested</label>
                        <input type="number" id="editCreativesCount" min="0">
                    </div>
                    <div class="form-group">
                        <label for="editCreativeId">Creative ID</label>
                        <input type="text" id="editCreativeId">
                    </div>
                </div>
                <div style="text-align: center;">
                    <button class="btn btn-success" onclick="saveEdit()">üíæ Save Changes</button>
                    <button class="btn btn-secondary" onclick="cancelEdit()">‚å´ Cancel</button>
                </div>
            </div>

            <!-- Add/Edit Hook Form (Hidden in Add-to-Existing mode) -->
            <div id="mainHookForm">
            <div class="controls">
                <div class="form-group">
                    <div class="book-header">
                        <label for="bookSelect">Book</label>
                        <button class="btn btn-xs btn-primary" onclick="toggleAddBookForm()">+ Add New</button>
                    </div>
                    <select id="bookSelect">
                        <option value="">Select Book...</option>
                    </select>
                    <div id="addBookForm" class="add-book-form">
                        <label for="newBook" style="position: absolute; left: -9999px;">New Book Title</label>
                        <input type="text" id="newBook" placeholder="Book title">
                        <button class="btn btn-xs btn-success" onclick="addNewBookFromForm()">‚úì</button>
                        <button class="btn btn-xs btn-secondary" onclick="cancelAddBook()">‚úó</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="hookName">Hook Name/Description</label>
                    <textarea id="hookName" rows="3" placeholder="Enter hook description..."></textarea>
                </div>
                <div class="form-group">
                    <label for="testDate">Test Month/Year</label>
                    <input type="text" id="testDate" placeholder="MM/YYYY (e.g., 03/2024)">
                </div>
                <div class="form-group">
                    <label for="totalSpendInput"><span id="spendLabel">Total Spend ($)</span></label>
                    <input type="number" id="totalSpendInput" step="0.01" min="0" placeholder="0.00">
                </div>
            </div>
            <div class="controls-row-2">
                <div class="form-group">
                    <label for="totalRevenueInput"><span id="revenueLabel">Total Revenue ($)</span></label>
                    <input type="number" id="totalRevenueInput" step="0.01" min="0" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label for="purchases"><span id="purchasesLabel">Number of Purchases</span></label>
                    <input type="number" id="purchases" min="0" placeholder="0">
                </div>
                <!-- Creatives count removed - always 1 for new hooks -->
                <div class="form-group">
                    <label for="creativeId">Creative ID (auto-generated)</label>
                    <input type="text" id="creativeId" placeholder="Auto-generated based on book and date" readonly>
                </div>
            </div>
            <div style="text-align: center; margin-bottom: 30px;">
                <button class="btn btn-primary" onclick="addOrUpdateHook()">
                    <span id="addButtonText">‚ûï Add Hook</span>
                </button>
                <button class="btn btn-secondary" onclick="clearForm()">üîÑ Clear Form</button>
            </div>
            </div>
            <!-- End mainHookForm -->

            <!-- Add to Existing Toggle (outside main form) -->
            <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                <label style="display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 600; cursor: pointer;">
                    <input type="checkbox" id="addToExistingToggle" onchange="toggleAddToExistingMode()" style="transform: scale(1.2);">
                    <span>üìà Add to Existing Hook/Creative</span>
                </label>
                <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">Check this to add new spend/revenue to an existing hook+creative combination</p>
            </div>

            <!-- Existing Hook Selection (Hidden by default) -->
            <div id="existingHookSelection" style="display: none; margin-bottom: 20px; padding: 20px; background: #e3f2fd; border-radius: 10px; border-left: 4px solid #2196f3;">
    <h4 style="margin-bottom: 15px; color: #1976d2;">Select Existing Hook + Creative</h4>
    <div class="form-group">
        <label for="existingHookSearch">üîç Search hooks:</label>
        <input type="text" id="existingHookSearch" placeholder="Type to filter by book, hook name, or creative ID..." 
               oninput="filterExistingHooks(this.value)" 
               style="margin-bottom: 10px; padding: 10px; border: 2px solid #2196f3; border-radius: 8px; width: 100%;">
        <span id="hookCountDisplay" style="font-size: 12px; color: #666; display: block; margin-bottom: 10px;"></span>
    </div>
    <div class="form-group">
        <label for="existingHookSelect">Choose existing combination:</label>
        <select id="existingHookSelect" onchange="loadExistingHookData()" style="font-family: monospace;">
            <option value="">Select existing hook+creative...</option>
        </select>
    </div>
                <div id="existingHookInfo" style="margin-top: 15px; padding: 10px; background: white; border-radius: 6px; font-size: 13px; display: none;">
                    <!-- Existing hook info will be populated here -->
                </div>
                
                <!-- Additional amounts and new test date grouped together -->
                <div id="additionalFieldsSection" style="margin-top: 20px; padding: 15px; background: white; border-radius: 8px; border: 2px dashed #2196f3; display: none;">
                    <h5 style="margin-bottom: 15px; color: #1976d2;">Add New Test Data</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div class="form-group">
                            <label for="additionalSpend">Additional Spend ($)</label>
                            <input type="number" id="additionalSpend" step="0.01" min="0" placeholder="0.00">
                        </div>
                        <div class="form-group">
                            <label for="additionalRevenue">Additional Revenue ($)</label>
                            <input type="number" id="additionalRevenue" step="0.01" min="0" placeholder="0.00">
                        </div>
                        <div class="form-group">
                            <label for="additionalPurchases">Additional Purchases</label>
                            <input type="number" id="additionalPurchases" min="0" placeholder="0">
                        </div>
                        <div class="form-group">
                            <label for="newTestDate">New Test Date (MM/YYYY)</label>
                            <input type="text" id="newTestDate" placeholder="MM/YYYY (e.g., 03/2024)">
                        </div>
                    </div>
                    <small style="color: #666; font-size: 12px; margin-top: 10px; display: block;">
                        Enter the amounts and date for this new test. These will be added to the existing totals.
                    </small>
                    
                    <!-- Save/Cancel buttons -->
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="btn btn-primary" onclick="addToExistingHook()" id="addToExistingBtn">
                            üìà Add to Existing
                        </button>
                        <button class="btn btn-secondary" onclick="clearAdditionalFields()">üîÑ Clear Fields</button>
                    </div>
                </div>
            </div>

            <!-- Filter Controls (moved to be right above table) -->
            <div class="controls" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 15px;">
                <div class="form-group">
                    <label for="bookFilter">Filter by Book</label>
                    <select id="bookFilter" onchange="applyHooksFilters()">
                        <option value="">All Books</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="performanceFilter">Filter by Performance</label>
                    <select id="performanceFilter" onchange="applyHooksFilters()">
                        <option value="">All Levels</option>
                        <option value="not-tested">Not Tested Yet</option>
                        <option value="testing-incomplete">Testing Not Complete</option>
                        <option value="testing">Testing</option>
                        <option value="validated">Validated</option>
                        <option value="early-scale">Early Scale</option>
                        <option value="proven-scale">Proven Scale</option>
                        <option value="mature-scale">Mature Scale</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>&nbsp;</label>
                    <button class="btn btn-secondary" onclick="clearHooksFilters()">üîÑ Clear Filters</button>
                </div>
            </div>

            <!-- Hooks Table with Sticky Headers -->
            <div class="table-wrapper">
                <table class="data-table" id="hooksTable">
                    <thead>
                        <tr>
                            <th>Book</th>
                            <th>Hook</th>
                            <th>Test<br>Month/Year</th>
                            <th>Total<br>Spend</th>
                            <th>Total<br>Revenue</th>
                            <th>Purchases</th>
                            <th>ROAS</th>
                            <th>Performance<br>Level</th>
                            <th>ROAS Milestones</th>
                            <th>Momentum<br>Score</th>
                            <th>Creative ID</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="hooksTableBody">
                    </tbody>
                </table>
            </div>
        </div>

       <!-- Books Management Tab -->
<div id="booksTab" class="tab-content">
    <div style="margin-bottom: 30px;">
        <h2>üìö Books Management & Strategic Analysis</h2>
        <p>View book performance, compare hooks, and identify winning creatives</p>
    </div>

    <div class="controls" style="grid-template-columns: 1fr 1fr;">
        <div class="form-group">
            <label for="newBookTitle">Add New Book</label>
            <input type="text" id="newBookTitle" placeholder="Enter book title">
        </div>
        <div class="form-group">
            <label>&nbsp;</label>
            <button class="btn btn-primary" onclick="addNewBook()">‚ûï Add Book</button>
        </div>
    </div>

    <div id="booksAnalysisView">
        <!-- Books will be rendered here by renderBooksAnalysis() -->
    </div>
</div>

           <!-- Archive Tab -->
        <div id="archiveTab" class="tab-content">
            <div style="margin-bottom: 30px;">
                <h2>üì¶ Archive</h2>
                <p>Archived hooks and creatives. You can restore them or permanently delete them.</p>
            </div>

            <!-- Archive Type Toggle -->
            <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                <label style="display: flex; align-items: center; gap: 10px; font-weight: 600; cursor: pointer;">
                    <input type="radio" name="archiveView" value="hooks" checked onchange="toggleArchiveView(this.value)" style="transform: scale(1.2);">
                    <span>üìã Archived Hooks (complete hook groups)</span>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; font-weight: 600; cursor: pointer; margin-top: 10px;">
                    <input type="radio" name="archiveView" value="creatives" onchange="toggleArchiveView(this.value)" style="transform: scale(1.2);">
                    <span>üé® Archived Creatives (by Creative ID)</span>
                </label>
            </div>

            <!-- Hooks Archive View -->
            <div id="hooksArchiveView" class="archive-view">
                <h3 style="margin-bottom: 15px;">Archived Hooks</h3>
                <div class="table-wrapper">
                    <table class="data-table" id="archiveTable">
                        <thead>
                            <tr>
                                <th>Book</th>
                                <th>Hook</th>
                                <th>Archived Date</th>
                                <th>Total Spend</th>
                                <th>Total Revenue</th>
                                <th>ROAS</th>
                                <th>Creative ID</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="archiveTableBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Creatives Archive View -->
            <div id="creativesArchiveView" class="archive-view" style="display: none;">
                <h3 style="margin-bottom: 15px;">Archived Creatives</h3>
                <div class="table-wrapper">
                    <table class="data-table" id="creativesArchiveTable">
                        <thead>
                            <tr>
                                <th>Creative ID</th>
                                <th>Hooks Count</th>
                                <th>Total Spend</th>
                                <th>Total Revenue</th>
                                <th>Overall ROAS</th>
                                <th>Archived Date</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="creativesArchiveTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
            
        <!-- Creative ID Tracker Tab -->
        <div id="creativesTab" class="tab-content">
            <div style="margin-bottom: 30px;">
                <h2>üé® Creative ID Tracker</h2>
                <p>Track performance of individual Creative IDs across all hooks and campaigns</p>
            </div>

            <!-- Search and Filter Controls -->
            <div class="controls" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
                <div class="form-group">
                    <label for="creativeSearch">Search Creative ID</label>
                    <input type="text" id="creativeSearch" placeholder="Search by Creative ID..." onkeyup="filterCreatives()">
                </div>
                <div class="form-group">
                    <label for="minRoasFilter">Min ROAS</label>
                    <input type="number" id="minRoasFilter" step="0.1" placeholder="e.g., 2.0" onchange="filterCreatives()">
                </div>
                <div class="form-group">
                    <label for="minSpendFilter">Min Spend ($)</label>
                    <input type="number" id="minSpendFilter" step="1" placeholder="e.g., 100" onchange="filterCreatives()">
                </div>
                <div class="form-group">
                    <label>&nbsp;</label>
                    <button class="btn btn-secondary" onclick="clearCreativeFilters()">üîÑ Clear Filters</button>
                </div>
            </div>

            <div class="table-wrapper">
                <table class="data-table creatives-table" id="creativesTable">
                    <thead>
                        <tr>
                            <th>Creative ID</th>
                            <th>Total Spend</th>
                            <th>Total Revenue</th>
                            <th>Overall ROAS</th>
                            <th>Hooks Used</th>
                            <th>Best Hook (ROAS)</th>
                            <th>Notes</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="creativesTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Firebase configuration using compat version
        const firebaseConfig = {
            apiKey: "AIzaSyAOJ9lDM3TCVdAra2G340jG5B3wyc4ABiU",
            authDomain: "ad-scaling-tracker.firebaseapp.com",
            projectId: "ad-scaling-tracker",
            storageBucket: "ad-scaling-tracker.firebasestorage.app",
            messagingSenderId: "83542485482",
            appId: "1:83542485482:web:721177b941fcc6f49e6a93",
            measurementId: "G-HLX0FY7BD1"
        };

        // Initialize Firebase with error handling
        let auth, db, provider;
        
        function initializeFirebase() {
            try {
                if (typeof firebase !== 'undefined') {
                    // Initialize Firebase
                    firebase.initializeApp(firebaseConfig);
                    auth = firebase.auth();
                    db = firebase.firestore();
                    provider = new firebase.auth.GoogleAuthProvider();

                    // Configure the Google Auth Provider
                    provider.setCustomParameters({
                        prompt: 'select_account'
                    });
                    
                    console.log('Firebase initialized successfully');
                    return true;
                } else {
                    console.log('Firebase not available yet');
                    return false;
                }
            } catch (error) {
                console.error('Firebase initialization error:', error);
                return false;
            }
        }

        // Global data storage
        let hooks = JSON.parse(localStorage.getItem('adScalingHooks') || '[]');
        let books = JSON.parse(localStorage.getItem('adScalingBooks') || '[]');
        let creativeNotes = JSON.parse(localStorage.getItem('adScalingCreativeNotes') || '{}');
        

        // Add to existing mode variables
        let isAddToExistingMode = false;
        let selectedExistingHook = null;

        function toggleAddToExistingMode() {
            const toggle = document.getElementById('addToExistingToggle');
            const existingSelection = document.getElementById('existingHookSelection');
            const mainHookForm = document.getElementById('mainHookForm');
            const addButtonText = document.getElementById('addButtonText');
            const spendLabel = document.getElementById('spendLabel');
            const revenueLabel = document.getElementById('revenueLabel');
            const purchasesLabel = document.getElementById('purchasesLabel');
            // creativesLabel removed since we removed the field
            
            isAddToExistingMode = toggle.checked;
            
            if (isAddToExistingMode) {
                // Hide main form and show existing hook selection
                mainHookForm.style.display = 'none';
                existingSelection.style.display = 'block';
                populateExistingHooks();
                clearForm();
            } else {
                // Show main form and hide existing hook selection
                mainHookForm.style.display = 'block';
                existingSelection.style.display = 'none';
                selectedExistingHook = null;
                clearForm();
                // Clear search
const searchInput = document.getElementById('existingHookSearch');
if (searchInput) {
    searchInput.value = '';
    filterExistingHooks('');
}
            }
        }

        function addToExistingHook() {
            // Handle adding to existing hook
            if (!selectedExistingHook) {
                alert('Please select an existing hook+creative combination first.');
                return;
            }
            
            const additionalSpend = parseFloat(document.getElementById('additionalSpend').value) || 0;
            const additionalRevenue = parseFloat(document.getElementById('additionalRevenue').value) || 0;
            const additionalPurchases = parseInt(document.getElementById('additionalPurchases').value) || 0;
            const newTestDate = document.getElementById('newTestDate').value.trim();
            
            if (additionalSpend === 0 && additionalRevenue === 0) {
                alert('Please enter at least additional spend or revenue.');
                return;
            }
            
            if (!newTestDate) {
                alert('Please enter the new test date (MM/YYYY format).');
                return;
            }
            
            // Validate date format
            if (!/^\d{2}\/\d{4}$/.test(newTestDate)) {
                alert('Please enter the date in MM/YYYY format (e.g., 03/2024).');
                return;
            }

            // Calculate PREVIOUS group totals BEFORE updating hook
            const groupHooks = hooks.filter(h => 
                h.book === selectedExistingHook.book && 
                h.hookName === selectedExistingHook.hookName
            );
            const previousGroupSpend = groupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
            const previousGroupRevenue = groupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
            const previousGroupROAS = previousGroupSpend > 0 ? previousGroupRevenue / previousGroupSpend : 0;
            
            // Find the hook in the array and update it
            const hookIndex = hooks.findIndex(h => 
                h.book === selectedExistingHook.book && 
                h.hookName === selectedExistingHook.hookName && 
                h.creativeId === selectedExistingHook.creativeId
            );
            
            if (hookIndex >= 0) {
                const existingHook = hooks[hookIndex];
                
                console.log(`üîç ADD TO EXISTING DEBUG:`);
                console.log(`  Before update - Individual Hook Spend: ${existingHook.totalSpend.toFixed(2)}, ROAS: ${existingHook.overallROAS.toFixed(2)}`);
                console.log(`  Before update - Group Spend: ${previousGroupSpend.toFixed(2)}, ROAS: ${previousGroupROAS.toFixed(2)}`);
                console.log(`  Adding - Spend: ${additionalSpend.toFixed(2)}, Revenue: ${additionalRevenue.toFixed(2)}`);
                
                // Update totals
                existingHook.totalSpend += additionalSpend;
                existingHook.totalRevenue += additionalRevenue;
                existingHook.purchases += additionalPurchases;
                existingHook.overallROAS = existingHook.totalSpend > 0 ? existingHook.totalRevenue / existingHook.totalSpend : 0;
                
                console.log(`  After update - Individual Hook Spend: ${existingHook.totalSpend.toFixed(2)}, ROAS: ${existingHook.overallROAS.toFixed(2)}`);
                
                // Update test date to the latest date (compare all dates properly)
                const existingTestDate = new Date(existingHook.testDate.split('/').reverse().join('-') + '-01');
                const newTestDateObj = new Date(newTestDate.split('/').reverse().join('-') + '-01');
                
                // Always update to the most recent date
                if (newTestDateObj > existingTestDate) {
                    existingHook.testDate = newTestDate;
                }
                
                // Format the new test date properly
                formatDateInput({value: newTestDate, dispatchEvent: () => {}});

                // Calculate NEW group totals AFTER updating hook
                const newGroupHooks = hooks.filter(h => 
                    h.book === selectedExistingHook.book && 
                    h.hookName === selectedExistingHook.hookName
                );
                const newGroupSpend = newGroupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
                const newGroupRevenue = newGroupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
                const newGroupROAS = newGroupSpend > 0 ? newGroupRevenue / newGroupSpend : 0;

                console.log(`  After update - New Group Spend: ${newGroupSpend.toFixed(2)}, ROAS: ${newGroupROAS.toFixed(2)}`);

                // Trigger group-level milestone tracking with accurate before/after totals
                const group = { 
                    book: selectedExistingHook.book, 
                    hookName: selectedExistingHook.hookName, 
                    creatives: newGroupHooks 
                };
                recordGroupMilestones(group, previousGroupSpend, previousGroupROAS, newGroupSpend, newGroupROAS);
                
                // Save data
                saveToLocalAndCloud();
                
                // Refresh UI
                renderHooks();
                renderBooks();
                renderCreatives();
                
                // Clear the additional fields
                clearAdditionalFields();
                
                // Refresh the existing hook selection with updated data
                populateExistingHooks();
                
                alert(`Successfully added $${additionalSpend.toFixed(2)} spend and $${additionalRevenue.toFixed(2)} revenue to existing hook!`);
                
                // Scroll to table
                document.getElementById('hooksTable').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'nearest' 
                });
            } else {
                alert('Error: Could not find the selected hook to update.');
            }
        }



        // NEW: Group-level milestone tracking - records ROAS when GROUP totals cross thresholds
        function recordGroupMilestones(group, previousGroupSpend, previousGroupROAS, newGroupSpend, newGroupROAS) {
            console.log(`üèÜ GROUP MILESTONE TRACKING START:`);
            console.log(`  Group: ${group.book} -> ${group.hookName}`);
            console.log(`  Previous Group Spend: ${previousGroupSpend.toFixed(2)}, ROAS: ${previousGroupROAS.toFixed(2)}`);
            console.log(`  New Group Spend: ${newGroupSpend.toFixed(2)}, ROAS: ${newGroupROAS.toFixed(2)}`);
            
            // Get or create a group milestone storage object
            let groupMilestones = getGroupMilestoneStorage(group);
            
            console.log(`  Current group milestones:`, groupMilestones);
            
            // Check each milestone threshold for the GROUP
            const milestones = [
                { threshold: 100, field: 'roasAt100' },
                { threshold: 300, field: 'roasAt300' },
                { threshold: 1000, field: 'roasAt1000' },
                { threshold: 3000, field: 'roasAt3000' }
            ];
            
            milestones.forEach(milestone => {
                const currentValue = groupMilestones[milestone.field] || 0;
                const crossingThreshold = newGroupSpend >= milestone.threshold && previousGroupSpend < milestone.threshold;
                const needsValue = currentValue === 0;
                
                console.log(`    Checking GROUP ${milestone.field} (threshold: ${milestone.threshold})`);
                console.log(`      Crossing threshold? ${crossingThreshold}, Needs value? ${needsValue}`);
                
                if (crossingThreshold && needsValue) {
                    let roasAtThreshold;
                    
                    if (previousGroupSpend === 0) {
                        // First entry that crosses threshold - use current ROAS
                        roasAtThreshold = newGroupROAS;
                        console.log(`      ‚úÖ First GROUP entry crossing ${milestone.threshold}: Using current ROAS ${roasAtThreshold.toFixed(2)}`);
                    } else {
                        // Interpolate ROAS at the exact threshold point for the GROUP
                        const spendDiff = newGroupSpend - previousGroupSpend;
                        const roasDiff = newGroupROAS - previousGroupROAS;
                        
                        if (spendDiff > 0) {
                            const thresholdProgress = (milestone.threshold - previousGroupSpend) / spendDiff;
                            roasAtThreshold = previousGroupROAS + (roasDiff * thresholdProgress);
                            console.log(`      ‚úÖ Interpolating GROUP ${milestone.threshold}: ${roasAtThreshold.toFixed(2)} (progress: ${thresholdProgress.toFixed(2)})`);
                        } else {
                            roasAtThreshold = newGroupROAS;
                            console.log(`      ‚úÖ No spend difference, using current GROUP ROAS: ${roasAtThreshold.toFixed(2)}`);
                        }
                    }
                    
                    groupMilestones[milestone.field] = roasAtThreshold;
                    console.log(`      üéØ SET GROUP ${milestone.field} = ${roasAtThreshold.toFixed(2)} (HISTORICAL VALUE LOCKED)`);
                    
                    // Save the group milestone back to storage
                    saveGroupMilestoneStorage(group, groupMilestones);
                } else if (currentValue > 0) {
                    console.log(`      üîí PRESERVING existing GROUP ${milestone.field} = ${currentValue.toFixed(2)} (historical value)`);
                } else {
                    console.log(`      ‚ùå Not crossing threshold or already have value, skipping`);
                }
            });
            
            console.log(`üèÜ GROUP MILESTONE TRACKING END - Final group milestones:`, groupMilestones);
            return groupMilestones;
        }

        // Helper function to get group milestone storage (using localStorage with group key)
        function getGroupMilestoneStorage(group) {
            const groupKey = `${group.book}||${group.hookName}`;
            const groupMilestones = JSON.parse(localStorage.getItem('groupMilestones') || '{}');
            return groupMilestones[groupKey] || {
                roasAt100: 0,
                roasAt300: 0,
                roasAt1000: 0,
                roasAt3000: 0
            };
        }

        // Helper function to save group milestone storage
        function saveGroupMilestoneStorage(group, milestones) {
            const groupKey = `${group.book}||${group.hookName}`;
            const allGroupMilestones = JSON.parse(localStorage.getItem('groupMilestones') || '{}');
            allGroupMilestones[groupKey] = milestones;
            localStorage.setItem('groupMilestones', JSON.stringify(allGroupMilestones));
            
            // Also sync to cloud if signed in
            if (isSignedIn) {
                saveDataToFirebase();
            }
        }

        // NEW FUNCTION: Initialize missing milestones for backfilled data
function initializeMissingMilestones() {
    let updatedCount = 0;
    const groupMilestonesData = JSON.parse(localStorage.getItem('groupMilestones') || '{}');
    
    // Group hooks by book + hookName
    const hookGroups = {};
    hooks.forEach(hook => {
        const key = `${hook.book}||${hook.hookName}`;
        if (!hookGroups[key]) {
            hookGroups[key] = {
                book: hook.book,
                hookName: hook.hookName,
                creatives: []
            };
        }
        hookGroups[key].creatives.push(hook);
    });
    
    // Check each group for missing milestones
    Object.keys(hookGroups).forEach(groupKey => {
        const group = hookGroups[groupKey];
        const totalSpend = group.creatives.reduce((sum, c) => sum + c.totalSpend, 0);
        const totalRevenue = group.creatives.reduce((sum, c) => sum + c.totalRevenue, 0);
        const currentROAS = totalSpend > 0 ? totalRevenue / totalSpend : 0;
        
        // Get or create group milestones
        if (!groupMilestonesData[groupKey]) {
            groupMilestonesData[groupKey] = {
                roasAt100: 0,
                roasAt300: 0,
                roasAt1000: 0,
                roasAt3000: 0
            };
        }
        
        const milestones = groupMilestonesData[groupKey];
        let groupUpdated = false;
        
        // Initialize any missing milestones based on current spend
        if (totalSpend >= 100 && milestones.roasAt100 === 0) {
            milestones.roasAt100 = currentROAS;
            groupUpdated = true;
            console.log(`‚úÖ Initialized $100 milestone for ${group.hookName}: ${currentROAS.toFixed(2)}`);
        }
        if (totalSpend >= 300 && milestones.roasAt300 === 0) {
            milestones.roasAt300 = currentROAS;
            groupUpdated = true;
            console.log(`‚úÖ Initialized $300 milestone for ${group.hookName}: ${currentROAS.toFixed(2)}`);
        }
        if (totalSpend >= 1000 && milestones.roasAt1000 === 0) {
            milestones.roasAt1000 = currentROAS;
            groupUpdated = true;
            console.log(`‚úÖ Initialized $1000 milestone for ${group.hookName}: ${currentROAS.toFixed(2)}`);
        }
        if (totalSpend >= 3000 && milestones.roasAt3000 === 0) {
            milestones.roasAt3000 = currentROAS;
            groupUpdated = true;
            console.log(`‚úÖ Initialized $3000 milestone for ${group.hookName}: ${currentROAS.toFixed(2)}`);
        }
        
        if (groupUpdated) {
            updatedCount++;
        }
    });
    
    // Save updated milestones
    if (updatedCount > 0) {
        localStorage.setItem('groupMilestones', JSON.stringify(groupMilestonesData));
        console.log(`üéØ Initialized milestones for ${updatedCount} hook groups`);
        return updatedCount;
    }
    
    return 0;
}

        function runMilestoneMigration() {
    if (confirm('This will initialize missing ROAS milestones for backfilled data. This is safe and won\'t overwrite existing milestones. Continue?')) {
        const count = initializeMissingMilestones();
        if (count > 0) {
            saveToLocalAndCloud();
            renderHooks();
            alert(`‚úÖ Fixed ${count} hooks with missing milestones!`);
        } else {
            alert('‚úÖ All milestones are already set - nothing to fix!');
        }
    }
}

        // UPDATED: calculateGroupMilestones now uses stored group milestones
        function calculateGroupMilestones(group, totalSpend, overallROAS) {
            console.log(`üéØ GROUP MILESTONE CALCULATION START:`);
            console.log(`  Group: ${group.book} -> ${group.hookName}`);
            console.log(`  Total Group Spend: ${totalSpend.toFixed(2)}`);
            console.log(`  Total Group ROAS: ${overallROAS.toFixed(2)}`);
            
            // Get stored group milestones
            const storedMilestones = getGroupMilestoneStorage(group);
            
            console.log(`  üìä Using stored group milestones:`, storedMilestones);
            
            // Return group milestones object
            const groupMilestones = {
                totalSpend,
                overallROAS,
                roasAt100: storedMilestones.roasAt100,
                roasAt300: storedMilestones.roasAt300,
                roasAt1000: storedMilestones.roasAt1000,
                roasAt3000: storedMilestones.roasAt3000
            };
            
            console.log(`üéØ GROUP MILESTONE CALCULATION END - Using stored historical values:`, {
                roasAt100: groupMilestones.roasAt100,
                roasAt300: groupMilestones.roasAt300,
                roasAt1000: groupMilestones.roasAt1000,
                roasAt3000: groupMilestones.roasAt3000
            });
            
            return groupMilestones;
        }

        // FIXED FUNCTION: Record milestone ROAS ONLY when crossing thresholds for the first time
        function recordMilestoneROAS(hook, previousSpend, previousROAS) {
            const newSpend = hook.totalSpend;
            const currentROAS = hook.overallROAS;
            
            console.log(`üîç MILESTONE DEBUG START:`);
            console.log(`  Hook: ${hook.hookName} (Creative: ${hook.creativeId})`);
            console.log(`  Previous Spend: ${previousSpend.toFixed(2)}`);
            console.log(`  New Spend: ${newSpend.toFixed(2)}`);
            console.log(`  Previous ROAS: ${previousROAS.toFixed(2)}`);
            console.log(`  Current ROAS: ${currentROAS.toFixed(2)}`);
            console.log(`  Current milestones:`, {
                roasAt100: hook.roasAt100,
                roasAt300: hook.roasAt300,
                roasAt1000: hook.roasAt1000,
                roasAt3000: hook.roasAt3000
            });
            
            // Ensure milestone fields exist and are initialized
            if (!hook.hasOwnProperty('roasAt100')) hook.roasAt100 = 0;
            if (!hook.hasOwnProperty('roasAt300')) hook.roasAt300 = 0;
            if (!hook.hasOwnProperty('roasAt1000')) hook.roasAt1000 = 0;
            if (!hook.hasOwnProperty('roasAt3000')) hook.roasAt3000 = 0;
            
            // Check each milestone threshold
            const milestones = [
                { threshold: 100, field: 'roasAt100' },
                { threshold: 300, field: 'roasAt300' },
                { threshold: 1000, field: 'roasAt1000' },
                { threshold: 3000, field: 'roasAt3000' }
            ];
            
            milestones.forEach(milestone => {
                console.log(`  Checking ${milestone.field} (threshold: ${milestone.threshold})`);
                console.log(`    Previous < threshold? ${previousSpend} < ${milestone.threshold} = ${previousSpend < milestone.threshold}`);
                console.log(`    New >= threshold? ${newSpend} >= ${milestone.threshold} = ${newSpend >= milestone.threshold}`);
                
                const currentValue = hook[milestone.field] || 0;
                console.log(`    Already has milestone? ${currentValue} > 0 = ${currentValue > 0}`);
                
                // FIXED: Check if we're crossing the threshold AND don't already have a value
                const crossingThreshold = newSpend >= milestone.threshold && previousSpend < milestone.threshold;
                const needsValue = currentValue === 0;
                
                console.log(`    Crossing threshold? ${crossingThreshold}, Needs value? ${needsValue}`);
                
                if (crossingThreshold && needsValue) {
                    let roasAtThreshold;
                    
                    if (previousSpend === 0) {
                        // First entry that crosses threshold - use current ROAS
                        roasAtThreshold = currentROAS;
                        console.log(`    ‚úÖ First entry crossing ${milestone.threshold}: Using current ROAS ${roasAtThreshold.toFixed(2)}`);
                    } else {
                        // Interpolate ROAS at the exact threshold point
                        const spendDiff = newSpend - previousSpend;
                        const roasDiff = currentROAS - previousROAS;
                        
                        if (spendDiff > 0) {
                            const thresholdProgress = (milestone.threshold - previousSpend) / spendDiff;
                            roasAtThreshold = previousROAS + (roasDiff * thresholdProgress);
                            console.log(`    ‚úÖ Interpolating for ${milestone.threshold}: ${roasAtThreshold.toFixed(2)} (progress: ${thresholdProgress.toFixed(2)})`);
                        } else {
                            // Edge case: no spend difference, use current ROAS
                            roasAtThreshold = currentROAS;
                            console.log(`    ‚úÖ No spend difference, using current ROAS: ${roasAtThreshold.toFixed(2)}`);
                        }
                    }
                    
                    hook[milestone.field] = roasAtThreshold;
                    console.log(`    üéØ SET ${milestone.field} = ${roasAtThreshold.toFixed(2)} (HISTORICAL VALUE LOCKED)`);
                } else if (currentValue > 0) {
                    console.log(`    üîí PRESERVING existing ${milestone.field} = ${currentValue.toFixed(2)} (historical value)`);
                } else {
                    console.log(`    ‚ùå Not crossing threshold or already have value, skipping`);
                }
            });
            
            console.log(`üîç MILESTONE DEBUG END - Final milestones:`, {
                roasAt100: hook.roasAt100,
                roasAt300: hook.roasAt300,
                roasAt1000: hook.roasAt1000,
                roasAt3000: hook.roasAt3000
            });
        }

        function clearAdditionalFields() {
            document.getElementById('additionalSpend').value = '';
            document.getElementById('additionalRevenue').value = '';
            document.getElementById('additionalPurchases').value = '';
            document.getElementById('newTestDate').value = '';
        }

        function populateExistingHooks() {
            const select = document.getElementById('existingHookSelect');
            const searchInput = document.getElementById('existingHookSearch');
            
            // Store all combinations for filtering
            const combinations = {};
            hooks.filter(hook => !hook.archived).forEach((hook, index) => {
                const key = `${hook.book}||${hook.hookName}||${hook.creativeId}`;
                if (!combinations[key]) {
                    combinations[key] = {
                        index: index,
                        hook: hook,
                        display: `${hook.book} ‚Üí ${hook.hookName.substring(0, 40)}${hook.hookName.length > 40 ? '...' : ''} ‚Üí ${hook.creativeId}`,
                        searchText: `${hook.book} ${hook.hookName} ${hook.creativeId}`.toLowerCase()
                    };
                }
            });
            
            // Sort by book, then hook name
            const sortedCombinations = Object.values(combinations).sort((a, b) => {
                if (a.hook.book !== b.hook.book) {
                    return a.hook.book.localeCompare(b.hook.book);
                }
                return a.hook.hookName.localeCompare(b.hook.hookName);
            });
            
            // Store for filtering
            window.allHookCombinations = sortedCombinations;
            
            // Initial render
            filterExistingHooks('');
        }

        function filterExistingHooks(searchTerm) {
            const select = document.getElementById('existingHookSelect');
            select.innerHTML = '<option value="">Select existing hook+creative...</option>';
            
            const filtered = window.allHookCombinations.filter(combo => 
                combo.searchText.includes(searchTerm.toLowerCase())
            );
            
            if (filtered.length === 0) {
                select.innerHTML = '<option value="">No matches found...</option>';
                return;
            }
            
            filtered.forEach(combo => {
                const option = document.createElement('option');
                option.value = combo.index;
                option.textContent = combo.display;
                select.appendChild(option);
            });
            
            // Update count display
            const countDisplay = document.getElementById('hookCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = `Showing ${filtered.length} of ${window.allHookCombinations.length} hooks`;
            }
        }

        function loadExistingHookData() {
            const select = document.getElementById('existingHookSelect');
            const infoDiv = document.getElementById('existingHookInfo');
            const additionalFieldsSection = document.getElementById('additionalFieldsSection');
            
            if (!select.value) {
                infoDiv.style.display = 'none';
                additionalFieldsSection.style.display = 'none';
                selectedExistingHook = null;
                return;
            }
            
            const hookIndex = parseInt(select.value);
            selectedExistingHook = hooks[hookIndex];
            
            // Display existing hook info
            infoDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div><strong>Book:</strong> ${selectedExistingHook.book}</div>
                    <div><strong>Hook:</strong> ${selectedExistingHook.hookName}</div>
                    <div><strong>Creative ID:</strong> <code>${selectedExistingHook.creativeId}</code></div>
                    <div><strong>Current Spend:</strong> $${selectedExistingHook.totalSpend.toFixed(2)}</div>
                    <div><strong>Current Revenue:</strong> $${selectedExistingHook.totalRevenue.toFixed(2)}</div>
                    <div><strong>Current ROAS:</strong> ${selectedExistingHook.overallROAS.toFixed(2)}</div>
                    <div><strong>Last Test:</strong> ${selectedExistingHook.testDate}</div>
                    <div><strong>Total Purchases:</strong> ${selectedExistingHook.purchases}</div>
                </div>
            `;
            infoDiv.style.display = 'block';
            additionalFieldsSection.style.display = 'block';
        }

        // Firebase auth and sync variables
        let currentUser = null;
        let isSignedIn = false;
        let lastSyncTime = null;

        // Initialize Firebase auth listener
        function initializeAuth() {
            // Check if Firebase is loaded
            if (typeof firebase === 'undefined') {
                console.log('Firebase not loaded yet, retrying in 1 second...');
                setTimeout(initializeAuth, 1000);
                return;
            }

            auth.onAuthStateChanged((user) => {
                currentUser = user;
                isSignedIn = !!user;
                updateAuthUI();
                
                if (user) {
                    // User signed in, load their data
                    loadDataFromFirebase();
                } else {
                    // User signed out
                    console.log('User signed out');
                }
            });
        }

        function updateAuthUI() {
            const loginScreen = document.getElementById('loginScreen');
            const mainApp = document.getElementById('mainApp');
            const userName = document.getElementById('userName');
            const userPhoto = document.getElementById('userPhoto');

            if (isSignedIn && currentUser) {
                // Hide login screen, show main app
                loginScreen.style.display = 'none';
                mainApp.style.display = 'block';
                userName.textContent = currentUser.displayName || currentUser.email;
                userPhoto.src = currentUser.photoURL || 'https://via.placeholder.com/40';
            } else {
                // Show login screen, hide main app
                loginScreen.style.display = 'block';
                mainApp.style.display = 'none';
            }
        }

        async function signInWithGoogle() {
            try {
                const loginStatus = document.getElementById('loginStatus');
                if (loginStatus) {
                    loginStatus.textContent = 'üîÑ Signing in...';
                }
                
                // Clear any existing auth state
                if (auth.currentUser) {
                    await auth.signOut();
                }
                
                // Try the popup sign-in
                const result = await auth.signInWithPopup(provider);
                console.log('Signed in successfully:', result.user);
                
                if (loginStatus) {
                    loginStatus.textContent = '‚úÖ Signed in successfully';
                }
            } catch (error) {
                console.error('Sign in error:', error);
                const loginStatus = document.getElementById('loginStatus');
                
                if (error.code === 'auth/popup-closed-by-user') {
                    if (loginStatus) {
                        loginStatus.innerHTML = '‚å´ Sign-in popup was closed. <button onclick="signInWithGoogle()" style="background: none; border: none; color: #667eea; text-decoration: underline; cursor: pointer;">Try again</button>';
                    }
                } else if (error.code === 'auth/popup-blocked') {
                    if (loginStatus) {
                        loginStatus.innerHTML = '‚å´ Popup blocked. Please allow popups and <button onclick="signInWithGoogle()" style="background: none; border: none; color: #667eea; text-decoration: underline; cursor: pointer;">try again</button>';
                    }
                } else if (error.code === 'auth/cancelled-popup-request') {
                    if (loginStatus) {
                        loginStatus.textContent = 'üîÑ Please complete the sign-in process...';
                    }
                    // Don't show an error for this one, just wait
                } else {
                    if (loginStatus) {
                        loginStatus.innerHTML = `‚å´ Sign in failed: ${error.message}. <button onclick="signInWithGoogle()" style="background: none; border: none; color: #667eea; text-decoration: underline; cursor: pointer;">Try again</button>`;
                    }
                }
            }
        }

        async function signOutFromGoogle() {
            try {
                await auth.signOut();
                console.log('Signed out successfully');
            } catch (error) {
                console.error('Sign out error:', error);
                alert('Failed to sign out: ' + error.message);
            }
        }

        async function saveDataToFirebase() {
            if (!isSignedIn || !currentUser) {
                console.log('Not signed in, skipping Firebase save');
                return;
            }

            try {
                const userData = {
                    hooks: hooks,
                    books: books,
                    creativeNotes: creativeNotes,
                    groupMilestones: JSON.parse(localStorage.getItem('groupMilestones') || '{}'),
                    lastUpdated: new Date().toISOString(),
                    version: 1
                };

                const userDocRef = db.collection('users').doc(currentUser.uid);
                await userDocRef.set(userData);
                
                console.log('Data saved to Firebase successfully');
            } catch (error) {
                console.error('Error saving to Firebase:', error);
                // Silently handle errors - user doesn't need to worry about this
            }
        }

        async function loadDataFromFirebase() {
            if (!isSignedIn || !currentUser) {
                console.log('Not signed in, skipping Firebase load');
                return;
            }

            try {
                const userDocRef = db.collection('users').doc(currentUser.uid);
                const docSnap = await userDocRef.get();

                if (docSnap.exists) {
                    const userData = docSnap.data();
                    
                    // Check if cloud data is newer than local data
                    const cloudLastUpdated = new Date(userData.lastUpdated || 0);
                    const localLastUpdated = new Date(localStorage.getItem('lastUpdated') || 0);
                    
                    if (cloudLastUpdated > localLastUpdated || !localStorage.getItem('adScalingHooks')) {
                        // Use cloud data
                        hooks = userData.hooks || [];
                        books = userData.books || [];
                        creativeNotes = userData.creativeNotes || {};
                        
                        // Load group milestones if they exist
                        if (userData.groupMilestones) {
                            localStorage.setItem('groupMilestones', JSON.stringify(userData.groupMilestones));
                        }
                        
                        // Update local storage
                        localStorage.setItem('adScalingHooks', JSON.stringify(hooks));
                        localStorage.setItem('adScalingBooks', JSON.stringify(books));
                        localStorage.setItem('adScalingCreativeNotes', JSON.stringify(creativeNotes));
                        localStorage.setItem('lastUpdated', userData.lastUpdated);
                        
                        // Run migration after loading data
                        const migratedCount = migrateExistingCreativeIds();
                        if (migratedCount > 0) {
                            console.log(`üîß Auto-migration after cloud load: Fixed ${migratedCount} Creative IDs`);
                        }
                        
                        // Initialize milestone fields for existing hooks
                        initializeMilestoneFields();
                        
                        // Refresh UI
                        updateBookOptions();
                        renderHooks();
                        renderBooks();
                        
                        console.log('Data loaded from cloud');
                    } else {
                        // Local data is newer, sync it to cloud
                        await saveDataToFirebase();
                    }
                } else {
                    // No cloud data exists, save current local data
                    await saveDataToFirebase();
                    console.log('Local data saved to cloud');
                }
            } catch (error) {
                console.error('Error loading from Firebase:', error);
                // Silently handle errors - user doesn't need to worry about this
            }
        }

        // NEW FUNCTION: Migrate old archived data to new soft-delete system
        function migrateArchivedData() {
            // Load old archived arrays
            const oldArchivedHooks = JSON.parse(localStorage.getItem('adScalingArchivedHooks') || '[]');
            const oldArchivedCreatives = JSON.parse(localStorage.getItem('adScalingArchivedCreatives') || '[]');
            
            let migrationCount = 0;
            
            // Migrate archived hooks
            oldArchivedHooks.forEach(archivedHook => {
                // Check if this hook isn't already in the hooks array
                const exists = hooks.find(h => 
                    h.book === archivedHook.book && 
                    h.hookName === archivedHook.hookName && 
                    h.creativeId === archivedHook.creativeId &&
                    h.testDate === archivedHook.testDate
                );
                
                if (!exists) {
                    // Add it back with archived flag
                    hooks.push({
                        ...archivedHook,
                        archived: true
                    });
                    migrationCount++;
                }
            });
            
            // Migrate archived creatives (if they used a different structure)
            oldArchivedCreatives.forEach(archivedCreative => {
                const exists = hooks.find(h => 
                    h.book === archivedCreative.book && 
                    h.hookName === archivedCreative.hookName && 
                    h.creativeId === archivedCreative.creativeId &&
                    h.testDate === archivedCreative.testDate
                );
                
                if (!exists) {
                    hooks.push({
                        ...archivedCreative,
                        archived: true,
                        archivedAsCreative: true
                    });
                    migrationCount++;
                }
            });
            
            if (migrationCount > 0) {
                console.log(`‚úÖ Migrated ${migrationCount} archived items to new system`);
                
                // Clear old archive storage
                localStorage.removeItem('adScalingArchivedHooks');
                localStorage.removeItem('adScalingArchivedCreatives');
                
                // Save updated hooks array
                saveToLocalAndCloud();
                
                return migrationCount;
            }
            
            return 0;
        }

        // NEW FUNCTION: Initialize milestone fields for existing hooks
        function initializeMilestoneFields() {
            let needsSave = false;
            hooks.forEach(hook => {
                if (!hook.hasOwnProperty('roasAt100')) {
                    hook.roasAt100 = 0;
                    needsSave = true;
                }
                if (!hook.hasOwnProperty('roasAt300')) {
                    hook.roasAt300 = 0;
                    needsSave = true;
                }
                if (!hook.hasOwnProperty('roasAt1000')) {
                    hook.roasAt1000 = 0;
                    needsSave = true;
                }
                if (!hook.hasOwnProperty('roasAt3000')) {
                    hook.roasAt3000 = 0;
                    needsSave = true;
                }
            });
            
            if (needsSave) {
                console.log('üîß Initialized milestone fields for existing hooks');
                saveToLocalAndCloud();
            }
        }

        // AUTO-MIGRATION: Rewrite all Creative IDs that don't match the new format
        function migrateExistingCreativeIds() {
            let updatedCount = 0;
            let existingCreativeIds = new Set();
            
            // Define the new format pattern: BookTitle-MMYYYY-### (exactly 3 parts separated by dashes)
            const newFormatPattern = /^[a-zA-Z0-9]{1,15}-\d{6}-\d{3}$/;
            
            // First pass: collect any existing IDs that already match the new format
            hooks.forEach(hook => {
                if (hook.creativeId && newFormatPattern.test(hook.creativeId.trim())) {
                    existingCreativeIds.add(hook.creativeId.trim());
                }
            });
            
            // Second pass: rewrite ALL Creative IDs that don't match the new format
            hooks.forEach(hook => {
                const currentId = hook.creativeId ? hook.creativeId.trim() : '';
                
                // If empty, malformed, or doesn't match new pattern - rewrite it
                if (!currentId || !newFormatPattern.test(currentId)) {
                    let newId;
                    let attempts = 0;
                    
                    // Generate a unique ID
                    do {
                        newId = generateCreativeId(hook.book, hook.testDate);
                        attempts++;
                    } while (existingCreativeIds.has(newId) && attempts < 20);
                    
                    const oldId = hook.creativeId || 'EMPTY';
                    hook.creativeId = newId;
                    existingCreativeIds.add(newId);
                    updatedCount++;
                    console.log(`üîÑ Rewrote Creative ID: "${oldId}" -> "${newId}" for hook: ${hook.hookName}`);
                }
            });
            
            if (updatedCount > 0) {
                saveToLocalAndCloud();
                console.log(`‚úÖ Migration complete: Rewrote ${updatedCount} Creative IDs to new format`);
                return updatedCount;
            } else {
                console.log('‚úÖ No Creative ID migration needed - all hooks already have valid new format IDs');
                return 0;
            }
        }

        // Modify existing save functions to also save to Firebase
        function saveToLocalAndCloud() {
            // Save to localStorage
            localStorage.setItem('adScalingHooks', JSON.stringify(hooks));
            localStorage.setItem('adScalingBooks', JSON.stringify(books));
            localStorage.setItem('adScalingCreativeNotes', JSON.stringify(creativeNotes));
            localStorage.setItem('lastUpdated', new Date().toISOString());
            
            // Save to Firebase if signed in
            if (isSignedIn) {
                saveDataToFirebase();
            }
        }

        function formatDateInput(dateInput) {
            let value = dateInput.value.trim();
            if (!value) return;
            
            // Handle MM/YYYY format
            if (value.includes('/')) {
                const parts = value.split('/');
                if (parts.length === 2) {
                    let month = parts[0].trim();
                    const year = parts[1].trim();
                    
                    // Pad month to 2 digits if it's a single digit
                    if (month.length === 1 && parseInt(month) >= 1 && parseInt(month) <= 9) {
                        month = '0' + month;
                    }
                    
                    // Validate month is between 01-12
                    const monthNum = parseInt(month);
                    if (monthNum >= 1 && monthNum <= 12 && year.length === 4) {
                        const formattedDate = `${month.padStart(2, '0')}/${year}`;
                        if (dateInput.value !== formattedDate) {
                            dateInput.value = formattedDate;
                            // Trigger change event to update Creative ID preview if needed
                            dateInput.dispatchEvent(new Event('change'));
                        }
                    }
                }
            }
        }

        function generateCreativeId(bookName, testDate) {
            console.log('generateCreativeId called with:', { bookName, testDate });
            
            // Clean the book name for use in ID
            const cleanBook = bookName.replace(/[^a-zA-Z0-9]/g, '').substring(0, 15);
            
            console.log('Cleaned book name:', cleanBook);
            
            // Convert MM/YYYY to MMYYYY format
            let dateStr = '';
            if (testDate && testDate.trim() && testDate.includes('/')) {
                const dateParts = testDate.trim().split('/');
                console.log('Date parts:', dateParts);
                if (dateParts.length === 2 && dateParts[0] && dateParts[1]) {
                    const month = dateParts[0].padStart(2, '0');
                    const year = dateParts[1];
                    // Validate month is 01-12 and year is 4 digits
                    if (month >= '01' && month <= '12' && year.length === 4) {
                        dateStr = month + year;
                        console.log('Valid date converted to:', dateStr);
                    }
                }
            }
            
            // Only fallback to current date if we couldn't parse the input date
            if (!dateStr) {
                console.log('Using fallback current date');
                const currentDate = new Date();
                const currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');
                const currentYear = currentDate.getFullYear();
                dateStr = currentMonth + currentYear;
            }
            
            const randomNum = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
            
            const result = `${cleanBook}-${dateStr}-${randomNum}`;
            console.log('Generated Creative ID:', result);
            
            return result;
        }

        function updateCreativeIdPreview() {
            const bookSelect = document.getElementById('bookSelect').value;
            const testDate = document.getElementById('testDate').value;
            const creativeIdInput = document.getElementById('creativeId');
            
            console.log('updateCreativeIdPreview called with:', { bookSelect, testDate });
            
            // Always generate a new ID when both book and date are selected
            if (bookSelect && testDate) {
                const previewId = generateCreativeId(bookSelect, testDate);
                creativeIdInput.value = previewId;
                creativeIdInput.placeholder = `Auto-generated: ${previewId}`;
                console.log('Set Creative ID to:', previewId);
            } else {
                creativeIdInput.value = '';
                creativeIdInput.placeholder = "Auto-generated based on book and date";
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Try to initialize Firebase first
            if (initializeFirebase()) {
                // Firebase loaded successfully, initialize auth
                setTimeout(initializeAuth, 100);
            } else {
                // Firebase not ready, try again
                let attempts = 0;
                const firebaseInterval = setInterval(() => {
                    attempts++;
                    if (initializeFirebase()) {
                        clearInterval(firebaseInterval);
                        setTimeout(initializeAuth, 100);
                    } else if (attempts > 10) {
                        clearInterval(firebaseInterval);
                        console.error('Failed to initialize Firebase after 10 attempts');
                        // Continue without Firebase - app will work locally
                    }
                }, 500);
            }
            
            updateBookOptions();

            // Migrate old archived data
const archivedMigrationCount = migrateArchivedData();
    if (archivedMigrationCount > 0) {
        console.log(`üîÑ Migration complete: Converted ${archivedMigrationCount} archived items`);
    }
            
            // Initialize milestone fields for existing data
            initializeMilestoneFields();
            
            // Run migration for existing data
    const creativeIdMigrationCount = migrateExistingCreativeIds();
    if (creativeIdMigrationCount > 0) {
        console.log(`üîß Auto-migration completed: Fixed ${creativeIdMigrationCount} Creative IDs`);
    }
            
            renderHooks();
            renderBooks();
            renderArchive();
            
            // Set today's month/year as default
            const testDateInput = document.getElementById('testDate');
            if (testDateInput) {
                const currentDate = new Date();
                const currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');
                const currentYear = currentDate.getFullYear();
                testDateInput.value = `${currentMonth}/${currentYear}`;
            }
            
            // Add event listeners for Creative ID preview (removed hookName)
            const bookSelect = document.getElementById('bookSelect');
            const testDate = document.getElementById('testDate');
            
            if (bookSelect) {
                bookSelect.addEventListener('change', updateCreativeIdPreview);
            }
            if (testDate) {
                testDate.addEventListener('change', updateCreativeIdPreview);
                testDate.addEventListener('input', updateCreativeIdPreview); // Add input listener for real-time updates
                testDate.addEventListener('blur', () => {
                    formatDateInput(testDate);
                    updateCreativeIdPreview(); // Update after formatting
                });
            }
            
            // Add event listeners for auth buttons with safety checks
            setTimeout(() => {
                const loginButton = document.getElementById('loginButton');
                const signOutButton = document.getElementById('signOutButton');
                
                if (loginButton) {
                    loginButton.addEventListener('click', signInWithGoogle);
                }
                if (signOutButton) {
                    signOutButton.addEventListener('click', signOutFromGoogle);
                }
                
                // Add date formatting to edit and additional date inputs
                const editTestDate = document.getElementById('editTestDate');
                const newTestDateInput = document.getElementById('newTestDate');
                
                if (editTestDate) {
                    editTestDate.addEventListener('blur', () => formatDateInput(editTestDate));
                }
                if (newTestDateInput) {
                    newTestDateInput.addEventListener('blur', () => formatDateInput(newTestDateInput));
                }
            }, 100);
        });

        function toggleAddBookForm() {
            const form = document.getElementById('addBookForm');
            if (form.classList.contains('active')) {
                form.classList.remove('active');
            } else {
                form.classList.add('active');
                document.getElementById('newBook').focus();
            }
        }

        function addNewBookFromForm() {
            const newBookTitle = document.getElementById('newBook').value.trim();
            if (!newBookTitle) {
                alert('Please enter a book title.');
                return;
            }

            if (books.includes(newBookTitle)) {
                alert('This book already exists.');
                return;
            }

            books.push(newBookTitle);
            saveToLocalAndCloud();
            document.getElementById('newBook').value = '';
            updateBookOptions();
            // Set the book select value AFTER updating options
            document.getElementById('bookSelect').value = newBookTitle;
            cancelAddBook();
        }

        function cancelAddBook() {
            const form = document.getElementById('addBookForm');
            form.classList.remove('active');
            document.getElementById('newBook').value = '';
        }

        function updateBookOptions() {
            const selects = ['bookSelect', 'editBookSelect'];
            
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (!select) return;
                
                const currentValue = select.value;
                
                // Clear existing options except the first
                select.innerHTML = '<option value="">Select Book...</option>';
                
                // Add books from storage
                books.forEach(book => {
                    const option = document.createElement('option');
                    option.value = book;
                    option.textContent = book;
                    select.appendChild(option);
                });
                
                // Restore selection if it still exists
                if (currentValue && books.includes(currentValue)) {
                    select.value = currentValue;
                }
            });
        }

        function addOrUpdateHook() {
            // This function now handles both new hooks AND milestone tracking
            
            const bookSelect = document.getElementById('bookSelect').value;
            const hookNameElement = document.getElementById('hookName');
            const hookName = hookNameElement ? hookNameElement.value.trim() : '';
            const testDate = document.getElementById('testDate').value;
            
            console.log('addOrUpdateHook form values:', { bookSelect, hookName, testDate });
            
            const totalSpend = parseFloat(document.getElementById('totalSpendInput').value) || 0;
            const totalRevenue = parseFloat(document.getElementById('totalRevenueInput').value) || 0;
            const purchases = parseInt(document.getElementById('purchases').value) || 0;
            const creativesCount = 1; // Always 1 for new hooks since we removed the field
            
            let creativeId = document.getElementById('creativeId').value.trim();

            if (!bookSelect || !hookName) {
                alert('Please select a book and enter a hook name.');
                return;
            }

            if (totalSpend === 0 && totalRevenue === 0) {
                alert('Please enter at least a spend or revenue amount.');
                return;
            }

            // Calculate PREVIOUS group totals BEFORE adding new hook
            const groupHooks = hooks.filter(h => h.book === bookSelect && h.hookName === hookName);
            const previousGroupSpend = groupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
            const previousGroupRevenue = groupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
            const previousGroupROAS = previousGroupSpend > 0 ? previousGroupRevenue / previousGroupSpend : 0;

            // Find existing hook with same book, hookName, and creativeId
            const existingIndex = hooks.findIndex(h => 
                h.book === bookSelect && h.hookName === hookName && h.creativeId === creativeId
            );

            const hookData = {
                book: bookSelect,
                hookName: hookName,
                testDate: testDate,
                totalSpend: totalSpend,
                totalRevenue: totalRevenue,
                purchases: purchases,
                creativesCount: creativesCount,
                creativeId: creativeId,
                overallROAS: totalSpend > 0 ? totalRevenue / totalSpend : 0,
                roasAt100: 0,
                roasAt300: 0,
                roasAt1000: 0,
                roasAt3000: 0
            };

            if (existingIndex >= 0) {
                // Update existing hook by adding new spend/revenue
                const existing = hooks[existingIndex];
                
                console.log(`üîç ADD NEW HOOK DEBUG (existing found):`);
                console.log(`  Hook: ${hookName}`);
                console.log(`  Previous Hook Spend: ${existing.totalSpend.toFixed(2)}, Adding: ${totalSpend.toFixed(2)}`);
                
                hookData.totalSpend = existing.totalSpend + totalSpend;
                hookData.totalRevenue = existing.totalRevenue + totalRevenue;
                hookData.purchases = existing.purchases + purchases;
                hookData.creativesCount = existing.creativesCount + creativesCount;
                hookData.overallROAS = hookData.totalSpend > 0 ? hookData.totalRevenue / hookData.totalSpend : 0;
                
                // Update test date to latest
                if (new Date(testDate) > new Date(existing.testDate)) {
                    hookData.testDate = testDate;
                } else {
                    hookData.testDate = existing.testDate;
                }
                
                // Keep the existing creative ID if no new one provided
                if (!creativeId && existing.creativeId) {
                    hookData.creativeId = existing.creativeId;
                }
                
                // Preserve existing milestones
                hookData.roasAt100 = existing.roasAt100 || 0;
                hookData.roasAt300 = existing.roasAt300 || 0;
                hookData.roasAt1000 = existing.roasAt1000 || 0;
                hookData.roasAt3000 = existing.roasAt3000 || 0;
                
                hooks[existingIndex] = hookData;
            } else {
                // New hook - add to array
                console.log(`üîç ADD NEW HOOK DEBUG (completely new):`);
                console.log(`  Hook: ${hookName}`);
                console.log(`  Initial Spend: ${hookData.totalSpend.toFixed(2)}, ROAS: ${hookData.overallROAS.toFixed(2)}`);
                
                hooks.push(hookData);
            }

            // Calculate NEW group totals AFTER adding/updating hook
            const newGroupHooks = hooks.filter(h => h.book === bookSelect && h.hookName === hookName);
            const newGroupSpend = newGroupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
            const newGroupRevenue = newGroupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
            const newGroupROAS = newGroupSpend > 0 ? newGroupRevenue / newGroupSpend : 0;

            console.log(`üèÜ GROUP MILESTONE CHECK:`);
            console.log(`  Previous Group Spend: ${previousGroupSpend.toFixed(2)}, ROAS: ${previousGroupROAS.toFixed(2)}`);
            console.log(`  New Group Spend: ${newGroupSpend.toFixed(2)}, ROAS: ${newGroupROAS.toFixed(2)}`);

            // Trigger group-level milestone tracking with accurate before/after totals
            const group = { book: bookSelect, hookName: hookName, creatives: newGroupHooks };
            recordGroupMilestones(group, previousGroupSpend, previousGroupROAS, newGroupSpend, newGroupROAS);

            // Save data
            saveToLocalAndCloud();
            
            // Force immediate UI update
            updateBookOptions();
            renderHooks();
            renderBooks();
            clearForm();
            
            // Scroll to the table so user can see the new entry
            document.getElementById('hooksTable').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'nearest' 
            });
        }

        function getMilestoneDisplay(hook) {
            const milestones = [
                { amount: 3000, value: hook.roasAt3000, label: '$3000' },
                { amount: 1000, value: hook.roasAt1000, label: '$1000' },
                { amount: 300, value: hook.roasAt300, label: '$300' },
                { amount: 100, value: hook.roasAt100, label: '$100' }
            ];

            // Find the highest milestone reached
            const highestMilestone = milestones.find(m => m.value > 0);
            
            if (!highestMilestone) {
                return {
                    display: 'No milestone reached',
                    hasHistory: false,
                    history: []
                };
            }

            // Get all reached milestones for history
            const reachedMilestones = milestones.filter(m => m.value > 0).reverse();
            
            return {
                display: `ROAS @ ${highestMilestone.label}: ${highestMilestone.value.toFixed(2)}`,
                hasHistory: reachedMilestones.length > 1,
                history: reachedMilestones
            };
        }

        function toggleMilestoneHistory(index) {
            const historyDiv = document.getElementById(`milestone-history-${index}`);
            const toggleBtn = document.getElementById(`milestone-toggle-${index}`);
            
            if (historyDiv.classList.contains('active')) {
                historyDiv.classList.remove('active');
                toggleBtn.textContent = 'Show History';
            } else {
                historyDiv.classList.add('active');
                toggleBtn.textContent = 'Hide History';
            }
        }

        function editHook(index) {
            const hook = hooks[index];
            
            // Close add-to-existing mode if it's open
            const addToExistingToggle = document.getElementById('addToExistingToggle');
            if (addToExistingToggle && addToExistingToggle.checked) {
                addToExistingToggle.checked = false;
                toggleAddToExistingMode();
            }
            
            // Hide the main add form and show edit form
            document.querySelectorAll('.controls, .controls-row-2').forEach(el => {
                if (!el.closest('#editForm')) {
                    el.style.display = 'none';
                }
            });
            
            // Hide the Add/Update button section
            const addButtonSection = document.querySelector('div[style*="text-align: center; margin-bottom: 30px;"]');
            if (addButtonSection) {
                addButtonSection.style.display = 'none';
            }
            
            // Populate edit form
            document.getElementById('editIndex').value = index;
            document.getElementById('editBookSelect').value = hook.book;
            document.getElementById('editHookName').value = hook.hookName;
            document.getElementById('editTestDate').value = hook.testDate;
            document.getElementById('editTotalSpend').value = hook.totalSpend;
            document.getElementById('editTotalRevenue').value = hook.totalRevenue;
            document.getElementById('editPurchases').value = hook.purchases;
            document.getElementById('editCreativesCount').value = hook.creativesCount || 1;
            document.getElementById('editCreativeId').value = hook.creativeId || '';
            
            // Show edit form
            document.getElementById('editForm').classList.add('active');
            
            // Scroll to edit form
            document.getElementById('editForm').scrollIntoView({ behavior: 'smooth' });
        }

        // FIXED SAVE EDIT FUNCTION WITH MILESTONE TRACKING
        function saveEdit() {
            const index = parseInt(document.getElementById('editIndex').value);
            const originalHook = hooks[index];
            
            // Calculate PREVIOUS group totals BEFORE editing
            const groupHooks = hooks.filter(h => h.book === originalHook.book && h.hookName === originalHook.hookName);
            const previousGroupSpend = groupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
            const previousGroupRevenue = groupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
            const previousGroupROAS = previousGroupSpend > 0 ? previousGroupRevenue / previousGroupSpend : 0;
            
            const hookData = {
                book: document.getElementById('editBookSelect').value,
                hookName: document.getElementById('editHookName').value.trim(),
                testDate: document.getElementById('editTestDate').value,
                totalSpend: parseFloat(document.getElementById('editTotalSpend').value) || 0,
                totalRevenue: parseFloat(document.getElementById('editTotalRevenue').value) || 0,
                purchases: parseInt(document.getElementById('editPurchases').value) || 0,
                creativesCount: parseInt(document.getElementById('editCreativesCount').value) || 0,
                creativeId: document.getElementById('editCreativeId').value.trim(),
                overallROAS: 0,
                // Preserve existing milestones
                roasAt100: originalHook.roasAt100 || 0,
                roasAt300: originalHook.roasAt300 || 0,
                roasAt1000: originalHook.roasAt1000 || 0,
                roasAt3000: originalHook.roasAt3000 || 0
            };

            hookData.overallROAS = hookData.totalSpend > 0 ? hookData.totalRevenue / hookData.totalSpend : 0;

            if (!hookData.book || !hookData.hookName) {
                alert('Book and Hook Name are required.');
                return;
            }

            console.log(`üîç EDIT FUNCTION DEBUG:`);
            console.log(`  Hook: ${hookData.hookName}`);
            console.log(`  Previous Group Spend: ${previousGroupSpend.toFixed(2)}, ROAS: ${previousGroupROAS.toFixed(2)}`);

            hooks[index] = hookData;

            // Calculate NEW group totals AFTER editing
            const newGroupHooks = hooks.filter(h => h.book === hookData.book && h.hookName === hookData.hookName);
            const newGroupSpend = newGroupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
            const newGroupRevenue = newGroupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
            const newGroupROAS = newGroupSpend > 0 ? newGroupRevenue / newGroupSpend : 0;

            console.log(`  New Group Spend: ${newGroupSpend.toFixed(2)}, ROAS: ${newGroupROAS.toFixed(2)}`);

            // Trigger group-level milestone tracking
            const group = { book: hookData.book, hookName: hookData.hookName, creatives: newGroupHooks };
            recordGroupMilestones(group, previousGroupSpend, previousGroupROAS, newGroupSpend, newGroupROAS);
            
            saveToLocalAndCloud();
            renderHooks();
            cancelEdit();
        }

        function cancelEdit() {
            document.getElementById('editForm').classList.remove('active');
            
            // Show the main add form again
            document.querySelectorAll('.controls, .controls-row-2').forEach(el => {
                if (!el.closest('#editForm')) {
                    el.style.display = '';
                }
            });
            
            // Show the Add/Update button section again
            const addButtonSection = document.querySelector('div[style*="text-align: center; margin-bottom: 30px;"]');
            if (addButtonSection) {
                addButtonSection.style.display = '';
            }
        }

        function getPerformanceLevel(spend, lastTestDate) {
            if (spend === 0) return { text: 'Not Tested Yet', class: 'not-tested' };
            
            // Parse MM/YYYY format and compare with 6 months ago
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            
            // Convert MM/YYYY to a comparable date (first day of that month)
            const dateParts = lastTestDate.split('/');
            if (dateParts.length === 2) {
                const month = parseInt(dateParts[0]) - 1; // Month is 0-indexed
                const year = parseInt(dateParts[1]);
                const testDate = new Date(year, month, 1); // First day of the month
                
                if (spend < 100) {
                    if (testDate < sixMonthsAgo) {
                        return { text: 'Testing Not Complete', class: 'testing-incomplete' };
                    }
                    return { text: 'Testing', class: 'testing' };
                }
            }
            
            if (spend < 300) return { text: 'Validated', class: 'validated' };
            if (spend < 1000) return { text: 'Early Scale', class: 'early-scale' };
            if (spend < 3000) return { text: 'Proven Scale', class: 'proven-scale' };
            return { text: 'Mature Scale', class: 'mature-scale' };
        }

        function getMomentumScore(hook) {
    const { totalSpend, overallROAS, roasAt100, roasAt300, roasAt1000, roasAt3000 } = hook;
    
    let momentumScore = 0;
    let trajectoryText = '';
    let benchmarkROAS = 0;
    
    // Find the appropriate milestone to compare against
    if (totalSpend >= 3000 && roasAt3000 > 0) {
        benchmarkROAS = roasAt3000;
        trajectoryText = 'Recent vs $3000';
    } else if (totalSpend >= 1000 && roasAt1000 > 0) {
        benchmarkROAS = roasAt1000;
        trajectoryText = 'Recent vs $1000';
    } else if (totalSpend >= 300 && roasAt300 > 0) {
        benchmarkROAS = roasAt300;
        trajectoryText = 'Recent vs $300';
    } else if (totalSpend >= 100 && roasAt100 > 0) {
        benchmarkROAS = roasAt100;
        trajectoryText = 'Recent vs $100';
    }
    
    if (benchmarkROAS > 0) {
        momentumScore = overallROAS / benchmarkROAS;
        const percentage = (momentumScore * 100).toFixed(0);
        
        // **NEW: Force red if current ROAS is unprofitable**
        if (overallROAS < 1.0) {
            return {
                text: `üî¥ ${percentage}%`,
                class: 'momentum-degrading',
                benchmark: trajectoryText + ' (Unprofitable)',
                value: momentumScore
            };
        }
        
        // Determine class and icon based on momentum
        let momentumClass, icon;
        if (momentumScore > 1.05) {
            momentumClass = 'momentum-accelerating';
            icon = 'üöÄ';
        } else if (momentumScore >= 0.95) {
            momentumClass = 'momentum-stable';
            icon = 'üü¢';
        } else if (momentumScore >= 0.85) {
            momentumClass = 'momentum-declining';
            icon = 'üü°';
        } else {
            momentumClass = 'momentum-degrading';
            icon = 'üî¥';
        }
        
        return {
            text: `${icon} ${percentage}%`,
            class: momentumClass,
            benchmark: trajectoryText,
            value: momentumScore
        };
    } else {
        return {
            text: '‚ö´ N/A',
            class: 'momentum-na',
            benchmark: 'Insufficient data',
            value: 0
        };
    }
}

        // FIXED NEXT ACTION LOGIC WITH TESTING NOT COMPLETE N/A
        function getNextAction(roas, spend, lastTestDate, creativeGroup, performanceLevel) {
            // FIXED: If Testing Not Complete, show N/A
            if (performanceLevel && performanceLevel.class === 'testing-incomplete') {
                return { text: 'N/A', class: 'action-na' };
            }
            
            // Parse MM/YYYY format and compare with 6 months ago
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            
            let testDate = sixMonthsAgo; // Default to old date if parsing fails
            const dateParts = lastTestDate.split('/');
            if (dateParts.length === 2) {
                const month = parseInt(dateParts[0]) - 1;
                const year = parseInt(dateParts[1]);
                testDate = new Date(year, month, 1);
            }
            
            const isOldTest = testDate < sixMonthsAgo;
            
            // Calculate optimization opportunity for hooks with multiple creatives
            let hasOptimizationOpportunity = false;
            let bestCreativeROAS = roas;
            
            if (creativeGroup && creativeGroup.creatives && creativeGroup.creatives.length > 1) {
                const creativeROASValues = creativeGroup.creatives.map(c => c.overallROAS).sort((a, b) => b - a);
                bestCreativeROAS = creativeROASValues[0];
                
                // Check if there's a significant gap between best and overall
                if (bestCreativeROAS - roas > 0.3) {
                    hasOptimizationOpportunity = true;
                }
            }

            // UNDER $100 GATE
            if (spend < 100) {
                if (isOldTest) return { text: 'üü° Test New Creative', class: 'action-test-creative' };
                if (roas >= 1.5) return { text: 'üü¢ Scale NOW', class: 'action-scale-now' };
                if (roas >= 1.2) return { text: 'üîµ Continue to $300', class: 'action-continue' };
                if (roas >= 1.0) return { text: 'üü° Test New Creative', class: 'action-test-creative' };
                return { text: 'üî¥ Kill', class: 'action-kill' };
            }
            
            // AT $300 GATE (Validation ‚Üí Early Scale)
            if (spend >= 100 && spend < 1000) {
                if (roas >= 1.3) return { text: 'üîµ Scale to $1K', class: 'action-scale-further' };
                if (roas >= 1.0) return { text: 'üü° Test New Creative', class: 'action-test-creative' };
                return { text: 'üî¥ Kill', class: 'action-kill' };
            }

            // AT $1000+ GATE (Proven Scale Gates)
            if (spend >= 1000) {
                // Check for optimization opportunity first
                if (hasOptimizationOpportunity && bestCreativeROAS > 1.5) {
                    return { text: 'üü£ Scale + Optimize', class: 'action-scale-optimize' };
                }
                
                // Scale Further conditions
                if (roas >= 1.3 || (roas >= 1.1 && bestCreativeROAS > 1.5)) {
                    return { text: 'üîµ Scale Further', class: 'action-scale-further' };
                }
                
                // Cap Here conditions
                if ((roas >= 1.1 && roas < 1.3) || (roas < 1.1 && bestCreativeROAS > 1.3)) {
                    return { text: '‚ö™ Cap Here', class: 'action-cap-here' };
                }
                
                // Phase Out conditions
                if (roas < 1.1 && bestCreativeROAS <= 1.3) {
                    return { text: 'üü† Phase Out', class: 'action-phase-out' };
                }
            }

            // Default fallback
            return { text: 'üîµ Continue', class: 'action-continue' };
        }

        // FILTER FUNCTIONS FOR HOOKS TRACKER
        function populateBookFilter() {
            const bookFilter = document.getElementById('bookFilter');
            if (!bookFilter) return;
            
            const currentValue = bookFilter.value;
            bookFilter.innerHTML = '<option value="">All Books</option>';
            
            books.forEach(book => {
                const option = document.createElement('option');
                option.value = book;
                option.textContent = book;
                bookFilter.appendChild(option);
            });
            
            // Restore selection
            if (currentValue && books.includes(currentValue)) {
                bookFilter.value = currentValue;
            }
        }

        function applyHooksFilters() {
            const bookFilter = document.getElementById('bookFilter')?.value || '';
            const performanceFilter = document.getElementById('performanceFilter')?.value || '';
            
            const tableRows = document.querySelectorAll('#hooksTableBody tr.hook-group');
            
            tableRows.forEach(row => {
                const bookCell = row.children[0]?.textContent?.trim() || '';
                const performanceCell = row.querySelector('.performance-badge')?.className || '';
                
                let showRow = true;
                
                // Filter by book
                if (bookFilter && !bookCell.includes(bookFilter)) {
                    showRow = false;
                }
                
                // Filter by performance level
                if (performanceFilter && !performanceCell.includes(performanceFilter)) {
                    showRow = false;
                }
                
                row.style.display = showRow ? 'table-row' : 'none';
                
                // Also hide/show related creative detail rows
                const groupIndex = row.querySelector('.expand-toggle')?.id?.replace('toggle-', '');
                if (groupIndex !== undefined) {
                    const creativeRows = document.querySelectorAll(`[id^="creative-${groupIndex}-"]`);
                    creativeRows.forEach(creativeRow => {
                        creativeRow.style.display = showRow ? 'none' : 'none'; // Keep details hidden by default
                    });
                }
            });
        }

        function clearHooksFilters() {
            document.getElementById('bookFilter').value = '';
            document.getElementById('performanceFilter').value = '';
            applyHooksFilters();
        }

        // FIXED: Updated renderHooks function to use the new calculateGroupMilestones function
       function renderHooks() {
    const tbody = document.getElementById('hooksTableBody');
    if (!tbody) {
        console.error('Could not find hooksTableBody element');
        return;
    }
    tbody.innerHTML = '';

    /// Group hooks by book + hookName (include all for accurate stats)
const hookGroups = {};
hooks.forEach(hook => {
        const key = `${hook.book}||${hook.hookName}`;
        if (!hookGroups[key]) {
            hookGroups[key] = {
                book: hook.book,
                hookName: hook.hookName,
                testDate: hook.testDate,
                creatives: []
            };
        }
        hookGroups[key].creatives.push(hook);
        
        // Update to latest test date using proper date comparison
        const currentGroupDate = new Date(hookGroups[key].testDate.split('/').reverse().join('-') + '-01');
        const hookDate = new Date(hook.testDate.split('/').reverse().join('-') + '-01');
        if (hookDate > currentGroupDate) {
            hookGroups[key].testDate = hook.testDate;
        }
    });

    // Render each hook group (sorted alphabetically by book, then hook name)
    const sortedKeys = Object.keys(hookGroups).sort((a, b) => {
        const groupA = hookGroups[a];
        const groupB = hookGroups[b];
        
        if (groupA.book !== groupB.book) {
            return groupA.book.localeCompare(groupB.book);
        }
        
        return groupA.hookName.localeCompare(groupB.hookName);
    });

    sortedKeys.forEach((key, groupIndex) => {
        const group = hookGroups[key];

        // Check if this group should be hidden (all creatives archived)
const allCreativesArchived = group.creatives.every(c => c.archived);
if (allCreativesArchived) {
    return; // Skip rendering this group entirely
}
        
        // Calculate aggregated totals
        const totalSpend = group.creatives.reduce((sum, c) => sum + c.totalSpend, 0);
        const totalRevenue = group.creatives.reduce((sum, c) => sum + c.totalRevenue, 0);
        const totalPurchases = group.creatives.reduce((sum, c) => sum + c.purchases, 0);
        const overallROAS = totalSpend > 0 ? totalRevenue / totalSpend : 0;
        
        // Calculate group-level milestones based on aggregated spend/ROAS
        const aggregatedHook = calculateGroupMilestones(group, totalSpend, overallROAS);

        const performance = getPerformanceLevel(totalSpend, group.testDate);
        const momentumScore = getMomentumScore(aggregatedHook);
        const milestoneData = getMilestoneDisplay(aggregatedHook);

        // Find best performing creative
        const bestCreative = group.creatives.reduce((best, creative) => 
            creative.overallROAS > (best?.overallROAS || 0) ? creative : best, null);

        // Main hook row
        const row = document.createElement('tr');
        row.className = 'hook-group';
        row.innerHTML = `
            <td>
                <button class="expand-toggle" onclick="toggleCreativeDetails(${groupIndex})" id="toggle-${groupIndex}">‚ñ∂</button>
                ${group.book}
            </td>
            <td>${group.hookName}</td>
            <td>${group.testDate}</td>
            <td>$${totalSpend.toFixed(2)}</td>
            <td>$${totalRevenue.toFixed(2)}</td>
            <td>${totalPurchases}</td>
            <td><span class="${getRoasColorClass(overallROAS)}">${overallROAS.toFixed(2)}</span></td>
            <td><span class="performance-badge ${performance.class}">${performance.text}</span></td>
            <td class="milestone-display">
                <div class="current-milestone">${milestoneData.display}</div>
                ${milestoneData.hasHistory ? `
                    <button id="milestone-toggle-${groupIndex}" class="milestone-toggle" onclick="toggleMilestoneHistory(${groupIndex})">Show History</button>
                    <div id="milestone-history-${groupIndex}" class="milestone-history">
                        ${milestoneData.history.map(m => `
                            <div class="milestone-item">ROAS @ ${m.label}: ${m.value.toFixed(2)}</div>
                        `).join('')}
                    </div>
                ` : ''}
            </td>
            <td>
                <span class="momentum-score ${momentumScore.class}" title="${momentumScore.benchmark}">
                    ${momentumScore.text}
                </span>
            </td>
            <td style="font-family: monospace; font-size: 12px;">
                ${group.creatives.length} creative${group.creatives.length !== 1 ? 's' : ''}
                <div class="creative-count" style="font-size: 11px; color: #666; margin-top: 2px;">
                    Best ROAS: ${bestCreative ? bestCreative.overallROAS.toFixed(2) : 'N/A'}
                </div>
            </td>
            <td>
    <button class="btn btn-info btn-sm" onclick="editHookGroup('${key}')">‚úèÔ∏è Edit</button>
    <button class="btn btn-warning btn-sm" onclick="archiveHookGroup('${key}')">üì¶ Archive</button>
    <button class="btn btn-danger btn-sm" onclick="deleteHookGroup('${key}')">‚å´ Delete</button>
</td>
        `;
        tbody.appendChild(row);

        // Creative detail rows (hidden by default)
        group.creatives.sort((a, b) => b.overallROAS - a.overallROAS);
        group.creatives.forEach((creative, creativeIndex) => {
            const isBest = creative === bestCreative;
            const detailRow = document.createElement('tr');
            detailRow.className = `creative-details ${isBest ? 'best-creative' : ''}`;
            detailRow.id = `creative-${groupIndex}-${creativeIndex}`;
            detailRow.innerHTML = `
                <td style="padding-left: 30px;">
                    ${isBest ? 'üëë ' : ''}Creative ${creativeIndex + 1}
                </td>
                <td style="font-size: 12px; color: #666;">${creative.hookName}</td>
                <td>${creative.testDate}</td>
                <td>$${creative.totalSpend.toFixed(2)}</td>
                <td>$${creative.totalRevenue.toFixed(2)}</td>
                <td>${creative.purchases}</td>
                <td><strong>${creative.overallROAS.toFixed(2)}</strong></td>
                <td colspan="3" style="font-size: 12px; color: #666;">
                    Creative performance details
                </td>
                <td style="font-family: monospace; font-size: 11px; word-break: break-all; white-space: normal;">${creative.creativeId}</td>
                <td>
                    <button class="btn btn-info btn-xs" onclick="editHook(${hooks.indexOf(creative)})">‚úèÔ∏è</button>
<button class="btn btn-warning btn-xs" onclick="archiveHook(${hooks.indexOf(creative)})">üì¶</button>
<button class="btn btn-danger btn-xs" onclick="deleteHook(${hooks.indexOf(creative)})">‚å´</button>
                </td>
            `;
            tbody.appendChild(detailRow);
        });
    });
    
    // Populate book filter after rendering
    populateBookFilter();
}

        function toggleBookGroup(bookIndex) {
    const bookContent = document.querySelectorAll('.book-group-' + bookIndex);
    const toggle = document.getElementById('book-toggle-' + bookIndex);
    
    if (toggle.textContent === '‚ñº') {
        toggle.textContent = '‚ñ∂';
        bookContent.forEach(row => row.style.display = 'none');
    } else {
        toggle.textContent = '‚ñº';
        bookContent.forEach(row => row.style.display = 'table-row');
    }
}
        
        function renderBooks() {
       // Books are now rendered through renderBooksAnalysis() instead
       // This function is kept for backward compatibility but does nothing
       renderBooksAnalysis();
   }

        function renderBooksAnalysis() {
    const container = document.getElementById('booksAnalysisView');
    if (!container) return;
    
    container.innerHTML = '';

    // Group hooks by book
    const bookGroups = {};
    hooks.forEach(hook => {
        if (!bookGroups[hook.book]) {
            bookGroups[hook.book] = [];
        }
        bookGroups[hook.book].push(hook);
    });

    // Sort books alphabetically
    const sortedBooks = Object.keys(bookGroups).sort();

    sortedBooks.forEach((bookName, bookIndex) => {
        const hooksInBook = bookGroups[bookName];
        
        // Group hooks by hookName to get aggregated stats
        const hookNameGroups = {};
        hooksInBook.forEach(hook => {
            if (!hookNameGroups[hook.hookName]) {
                hookNameGroups[hook.hookName] = {
                    hookName: hook.hookName,
                    creatives: []
                };
            }
            hookNameGroups[hook.hookName].creatives.push(hook);
        });

        // Calculate book-level totals
        const bookTotalSpend = hooksInBook.reduce((sum, h) => sum + h.totalSpend, 0);
        const bookTotalRevenue = hooksInBook.reduce((sum, h) => sum + h.totalRevenue, 0);
        const bookAvgROAS = bookTotalSpend > 0 ? bookTotalRevenue / bookTotalSpend : 0;
        const bookHookCount = Object.keys(hookNameGroups).length;

        // Create book card
        const bookCard = document.createElement('div');
        bookCard.className = 'book-analysis-card';
        bookCard.innerHTML = `
            <div class="book-card-header" onclick="toggleBookAnalysis(${bookIndex})">
                <div class="book-card-title">
                    <span id="book-analysis-toggle-${bookIndex}" style="display: inline-block; width: 25px; font-size: 18px;">‚ñº</span>
                    <span style="font-size: 24px; font-weight: bold;">üìö ${bookName}</span>
                </div>
                <div class="book-card-stats">
                    <div class="book-stat">
                        <div class="book-stat-value">${bookHookCount}</div>
                        <div class="book-stat-label">Hooks</div>
                    </div>
                    <div class="book-stat">
                        <div class="book-stat-value">$${bookTotalSpend.toFixed(0)}</div>
                        <div class="book-stat-label">Total Spend</div>
                    </div>
                    <div class="book-stat">
                        <div class="book-stat-value">$${bookTotalRevenue.toFixed(0)}</div>
                        <div class="book-stat-label">Total Revenue</div>
                    </div>
                    <div class="book-stat">
                        <div class="book-stat-value ${getRoasColorClass(bookAvgROAS)}">${bookAvgROAS.toFixed(2)}</div>
                        <div class="book-stat-label">Avg ROAS</div>
                    </div>
                </div>
            </div>
            <div class="book-card-content book-analysis-content-${bookIndex}">
                <div class="hooks-list">
                    ${renderBookHooks(bookName, hookNameGroups, bookIndex)}
                </div>
            </div>
        `;
        container.appendChild(bookCard);
    });
}

function renderBookHooks(bookName, hookNameGroups, bookIndex) {
    // Sort hooks by ROAS (descending)
    const sortedHooks = Object.values(hookNameGroups).sort((a, b) => {
        const roasA = a.creatives.reduce((sum, c) => sum + c.totalSpend, 0) > 0 
            ? a.creatives.reduce((sum, c) => sum + c.totalRevenue, 0) / a.creatives.reduce((sum, c) => sum + c.totalSpend, 0) 
            : 0;
        const roasB = b.creatives.reduce((sum, c) => sum + c.totalSpend, 0) > 0 
            ? b.creatives.reduce((sum, c) => sum + c.totalRevenue, 0) / b.creatives.reduce((sum, c) => sum + c.totalSpend, 0) 
            : 0;
        return roasB - roasA;
    });

    let html = '<div class="hooks-table-wrapper"><table class="hooks-analysis-table"><thead><tr><th style="width: 10%;">Rank</th><th style="width: 35%;">Hook Name</th><th style="width: 15%;">ROAS</th><th style="width: 15%;">Spend</th><th style="width: 25%;">Best Creative ID</th></tr></thead><tbody>';

    sortedHooks.forEach((hookGroup, index) => {
        const totalSpend = hookGroup.creatives.reduce((sum, c) => sum + c.totalSpend, 0);
        const totalRevenue = hookGroup.creatives.reduce((sum, c) => sum + c.totalRevenue, 0);
        const overallROAS = totalSpend > 0 ? totalRevenue / totalSpend : 0;
        
        // Find best creative
        const bestCreative = hookGroup.creatives.reduce((best, creative) => 
            creative.overallROAS > (best?.overallROAS || 0) ? creative : best, null);

        let rankMedal = '';
        if (index === 0) rankMedal = 'ü•á';
        else if (index === 1) rankMedal = 'ü•à';
        else if (index === 2) rankMedal = 'ü•â';
        else rankMedal = `${index + 1}.`;

        const hookRowId = `hook-${bookIndex}-${index}`;

        html += `
            <tr class="hook-row" onclick="toggleHookCreatives('${hookRowId}')">
                <td style="text-align: center; font-size: 20px;">${rankMedal}</td>
                <td><strong>${hookGroup.hookName}</strong></td>
                <td><span class="${getRoasColorClass(overallROAS)}" style="font-size: 16px;">${overallROAS.toFixed(2)}</span></td>
                <td>$${totalSpend.toFixed(2)}</td>
                <td style="font-family: monospace; font-size: 12px;">
                    ${bestCreative ? `<a href="#" onclick="filterCreativeById('${bestCreative.creativeId}'); return false;" style="color: #667eea; text-decoration: none;">${bestCreative.creativeId}</a>` : 'N/A'}
                </td>
            </tr>
            <tr id="${hookRowId}" class="hook-creatives-row" style="display: none;">
                <td colspan="5" style="padding: 0;">
                    <div style="background: #f8f9fa; padding: 15px; border-top: 2px solid #e2e8f0;">
                        <strong style="margin-bottom: 10px; display: block;">All Creatives for "${hookGroup.hookName}":</strong>
                        <table style="width: 100%; font-size: 13px;">
                            <thead>
                                <tr style="background: #e2e8f0;">
                                    <th style="padding: 8px;">Creative ID</th>
                                    <th style="padding: 8px;">ROAS</th>
                                    <th style="padding: 8px;">Spend</th>
                                    <th style="padding: 8px;">Revenue</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${hookGroup.creatives.sort((a, b) => b.overallROAS - a.overallROAS).map(creative => `
                                    <tr style="border-bottom: 1px solid #e2e8f0;">
                                        <td style="padding: 8px; font-family: monospace; font-size: 11px;">
                                            <a href="#" onclick="filterCreativeById('${creative.creativeId}'); return false;" style="color: #667eea; text-decoration: none;">${creative.creativeId}</a>
                                        </td>
                                        <td style="padding: 8px;"><span class="${getRoasColorClass(creative.overallROAS)}">${creative.overallROAS.toFixed(2)}</span></td>
                                        <td style="padding: 8px;">$${creative.totalSpend.toFixed(2)}</td>
                                        <td style="padding: 8px;">$${creative.totalRevenue.toFixed(2)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </td>
            </tr>
        `;
    });

    html += '</tbody></table></div>';
    return html;
}

function toggleBookAnalysis(bookIndex) {
    const content = document.querySelector('.book-analysis-content-' + bookIndex);
    const toggle = document.getElementById('book-analysis-toggle-' + bookIndex);
    
    if (content.style.display === 'none') {
        content.style.display = 'block';
        toggle.textContent = '‚ñº';
    } else {
        content.style.display = 'none';
        toggle.textContent = '‚ñ∂';
    }
}

function toggleHookCreatives(hookRowId) {
    const row = document.getElementById(hookRowId);
    if (row.style.display === 'none') {
        row.style.display = 'table-row';
    } else {
        row.style.display = 'none';
    }
}

function filterCreativeById(creativeId) {
    // Switch to Creative ID Tracker tab
    switchTab('creatives');
    
    // Set the search filter
    document.getElementById('creativeSearch').value = creativeId;
    
    // Trigger the filter
    filterCreatives();
    
    // Scroll to top of page
    window.scrollTo({ top: 0, behavior: 'smooth' });
}
        
        function addNewBook() {
            const newBookTitle = document.getElementById('newBookTitle').value.trim();
            if (!newBookTitle) {
                alert('Please enter a book title.');
                return;
            }

            if (books.includes(newBookTitle)) {
                alert('This book already exists.');
                return;
            }

            books.push(newBookTitle);
            saveToLocalAndCloud();
            document.getElementById('newBookTitle').value = '';
            updateBookOptions();
            renderBooks();
            renderBooksAnalysis();
        }

        function editBookTitle(oldTitle) {
            const newTitle = prompt('Enter new book title:', oldTitle);
            if (!newTitle || newTitle === oldTitle) return;

            if (books.includes(newTitle)) {
                alert('This book title already exists.');
                return;
            }

            // Update book in books array
            const index = books.indexOf(oldTitle);
            if (index > -1) {
                books[index] = newTitle;
            }

            // Update all hooks that use this book
            hooks.forEach(hook => {
                if (hook.book === oldTitle) {
                    hook.book = newTitle;
                }
            });

            saveToLocalAndCloud();
            updateBookOptions();
            renderBooks();
            renderBooksAnalysis();
            renderHooks();
        }

        function deleteBook(bookTitle) {
            const bookHooks = hooks.filter(h => h.book === bookTitle);
            if (bookHooks.length > 0) {
                if (!confirm(`This book has ${bookHooks.length} hooks. Deleting it will also delete all associated hooks. Continue?`)) {
                    return;
                }
                // Remove all hooks for this book
                hooks = hooks.filter(h => h.book !== bookTitle);
                saveToLocalAndCloud();
            }

            // Remove book
            books = books.filter(b => b !== bookTitle);
            saveToLocalAndCloud();
            
            updateBookOptions();
            renderBooks();
            renderBooksAnalysis();
            renderHooks();
        }

        function deleteHook(index) {
            if (confirm('Are you sure you want to delete this hook?')) {
                hooks.splice(index, 1);
                saveToLocalAndCloud();
                renderHooks();
            }
        }

        function clearForm() {
            if (!isAddToExistingMode) {
                // Normal mode - clear all fields
                document.getElementById('bookSelect').value = '';
                document.getElementById('hookName').value = '';
                const currentDate = new Date();
                const currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');
                const currentYear = currentDate.getFullYear();
                document.getElementById('testDate').value = `${currentMonth}/${currentYear}`;
                document.getElementById('totalSpendInput').value = '';
                document.getElementById('totalRevenueInput').value = '';
                document.getElementById('purchases').value = '';
                // creativesCount removed - always 1 for new hooks
                document.getElementById('creativeId').value = '';
                document.getElementById('creativeId').setAttribute('readonly', 'readonly');
                document.getElementById('creativeId').placeholder = "Auto-generated based on book and date";
                cancelAddBook(); // Hide add book form if open
            } else {
                // In existing mode, clear the selection and additional fields
                document.getElementById('existingHookSelect').value = '';
                document.getElementById('existingHookInfo').style.display = 'none';
                document.getElementById('additionalFieldsSection').style.display = 'none';
                clearAdditionalFields();
                selectedExistingHook = null;
            }
        }

        function exportData() {
            // Get group milestones from localStorage
            const groupMilestones = JSON.parse(localStorage.getItem('groupMilestones') || '{}');
            
            const csvContent = "data:text/csv;charset=utf-8," + 
                "Book,Hook Name,Test Month/Year,Total Spend,Total Revenue,Purchases,Creatives Count,Creative ID,Overall ROAS,Performance Level,ROAS @$100,ROAS @$300,ROAS @$1000,ROAS @$3000,Momentum Score,Group ROAS @$100,Group ROAS @$300,Group ROAS @$1000,Group ROAS @$3000,Archived\n" +
                hooks.map(hook => {
                    const performance = getPerformanceLevel(hook.totalSpend, hook.testDate);
                    const momentumScore = getMomentumScore(hook);
                    
                    // Get group-level milestones for this hook
                    const groupKey = `${hook.book}||${hook.hookName}`;
                    const groupMilestone = groupMilestones[groupKey] || {
                        roasAt100: 0,
                        roasAt300: 0,
                        roasAt1000: 0,
                        roasAt3000: 0
                    };
                    
                    return `"${hook.book}","${hook.hookName.replace(/"/g, '""')}","${hook.testDate}",${hook.totalSpend},${hook.totalRevenue},${hook.purchases},${hook.creativesCount},"${hook.creativeId || ''}",${hook.overallROAS.toFixed(2)},"${performance.text}",${hook.roasAt100 > 0 ? hook.roasAt100.toFixed(2) : ''},${hook.roasAt300 > 0 ? hook.roasAt300.toFixed(2) : ''},${hook.roasAt1000 > 0 ? hook.roasAt1000.toFixed(2) : ''},${hook.roasAt3000 > 0 ? hook.roasAt3000.toFixed(2) : ''},"${momentumScore.text}",${groupMilestone.roasAt100 > 0 ? groupMilestone.roasAt100.toFixed(2) : ''},${groupMilestone.roasAt300 > 0 ? groupMilestone.roasAt300.toFixed(2) : ''},${groupMilestone.roasAt1000 > 0 ? groupMilestone.roasAt1000.toFixed(2) : ''},${groupMilestone.roasAt3000 > 0 ? groupMilestone.roasAt3000.toFixed(2) : ''},${hook.archived ? 'Yes' : 'No'}`;
                }).join("\n");

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `ad_scaling_tracker_${new Date().toISOString().split('T')[0]}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    const lines = text.split('\n');
                    
                    if (lines.length < 2) {
                        alert('File appears to be empty or has no data rows.');
                        return;
                    }
                    
                    // Parse header row to find column positions
                    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '').toLowerCase());
                    
                    console.log('üìã Found headers:', headers);
                    
                    // Map column names to indices (flexible - any order works!)
                    const columnMap = {
                        book: headers.findIndex(h => h.includes('book')),
                        hookName: headers.findIndex(h => h.includes('hook') && h.includes('name')),
                        testDate: headers.findIndex(h => h.includes('test') || h.includes('month') || h.includes('date')),
                        totalSpend: headers.findIndex(h => h.includes('spend')),
                        totalRevenue: headers.findIndex(h => h.includes('revenue')),
                        purchases: headers.findIndex(h => h.includes('purchase')),
                        creativesCount: headers.findIndex(h => h.includes('creative') && h.includes('count')),
                        creativeId: headers.findIndex(h => h.includes('creative') && h.includes('id'))
                    };
                    
                    // Validate required columns
                    const required = ['book', 'hookName', 'totalSpend', 'totalRevenue'];
                    const missing = required.filter(col => columnMap[col] === -1);
                    
                    if (missing.length > 0) {
                        alert(`Missing required columns: ${missing.join(', ')}\n\nRequired columns:\n- Book\n- Hook Name\n- Total Spend\n- Total Revenue`);
                        return;
                    }
                    
                    let importedCount = 0;
let skippedCount = 0;
let consolidatedInFile = 0;

// First pass: consolidate duplicate rows within the CSV
const csvRows = [];
for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === '') continue;
    
    const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
    
    // Extract values using the column map
const book = values[columnMap.book] || '';
const hookName = values[columnMap.hookName] || '';
let testDate = values[columnMap.testDate] || '';

// Normalize date format (handle MM/YYYY, M/YYYY, Mon-YY, etc.)
if (testDate) {
    // Convert "Jul-25" or "Aug-25" format to "07/2025"
    const monthNames = {
        'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
        'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
        'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
    };
    
    // Check if it's in "Mon-YY" format
    if (testDate.includes('-')) {
        const parts = testDate.toLowerCase().split('-');
        if (parts.length === 2 && monthNames[parts[0].substring(0, 3)]) {
            const month = monthNames[parts[0].substring(0, 3)];
            const year = parts[1].length === 2 ? '20' + parts[1] : parts[1];
            testDate = month + '/' + year;
        }
    }
    
    // Ensure MM/YYYY format (pad single digit months)
    if (testDate.includes('/')) {
        const parts = testDate.split('/');
        if (parts.length === 2) {
            const month = parts[0].padStart(2, '0');
            const year = parts[1].length === 2 ? '20' + parts[1] : parts[1];
            testDate = month + '/' + year;
        }
    }
}

console.log(`üìÖ Normalized date: ${testDate}`);

const totalSpend = parseFloat(values[columnMap.totalSpend]) || 0;
const totalRevenue = parseFloat(values[columnMap.totalRevenue]) || 0;
const purchases = parseInt(values[columnMap.purchases]) || 0;
const creativesCount = parseInt(values[columnMap.creativesCount]) || 1;
let creativeId = columnMap.creativeId !== -1 ? values[columnMap.creativeId] : '';
    
    // Skip if missing critical data
    if (!book || !hookName || totalSpend === 0) {
        console.log(`‚ö†Ô∏è Skipping row ${i + 1}: Missing book, hook name, or spend`);
        skippedCount++;
        continue;
    }
    
    // Auto-generate Creative ID if not provided
if (!creativeId) {
    try {
        creativeId = generateCreativeId(book, testDate);
        console.log(`üîß Generated Creative ID: ${creativeId} for ${book} - ${hookName}`);
    } catch (error) {
        console.error(`‚ùå Error generating Creative ID for ${book} - ${hookName} with date ${testDate}:`, error);
        // Use a simple fallback if date is invalid
        const cleanBook = book.replace(/[^a-zA-Z0-9]/g, '').substring(0, 15);
        const randomNum = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        creativeId = `${cleanBook}-ERROR-${randomNum}`;
        console.log(`üîß Using fallback Creative ID: ${creativeId}`);
        console.log(`   Please fix the date format: "${testDate}" is not valid MM/YYYY format`);
    }
}
    
    // Check if we already have this combination in csvRows
// (consolidate by Book + Hook + Creative ID, regardless of date)
const existingRow = csvRows.find(r => 
    r.book === book && 
    r.hookName === hookName && 
    r.creativeId === creativeId
);
    
    if (existingRow) {
    // Consolidate within CSV
    console.log(`üîó Consolidating duplicate CSV row: ${book} - ${hookName} - ${creativeId}`);
    existingRow.totalSpend += totalSpend;
    existingRow.totalRevenue += totalRevenue;
    existingRow.purchases += purchases;
    existingRow.creativesCount += creativesCount;
    
    // Update to the latest test date
    const existingDate = new Date(existingRow.testDate.split('/').reverse().join('-') + '-01');
    const newDate = new Date(testDate.split('/').reverse().join('-') + '-01');
    if (newDate > existingDate) {
        existingRow.testDate = testDate;
    }
    
    consolidatedInFile++;
} else {
        // Add new row to process
        csvRows.push({
            book,
            hookName,
            testDate,
            totalSpend,
            totalRevenue,
            purchases,
            creativesCount,
            creativeId
        });
    }
}

// Second pass: process consolidated rows
for (const row of csvRows) {
    const { book, hookName, testDate, totalSpend, totalRevenue, purchases, creativesCount, creativeId } = row;
    
    // Add book if it doesn't exist
    if (!books.includes(book)) {
        books.push(book);
        console.log(`‚úÖ Added new book: ${book}`);
    }
    
    // Calculate PREVIOUS group totals for milestone tracking
    const groupHooks = hooks.filter(h => h.book === book && h.hookName === hookName);
    const previousGroupSpend = groupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
    const previousGroupRevenue = groupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
    const previousGroupROAS = previousGroupSpend > 0 ? previousGroupRevenue / previousGroupSpend : 0;
    
    // Check if this hook already exists (by Book + Hook + Creative ID only)
    const existingIndex = hooks.findIndex(h => 
        h.book === book && 
        h.hookName === hookName && 
        h.creativeId === creativeId
    );
    
    if (existingIndex >= 0) {
        // Check for potential duplicate (same spend amount within $1)
        const existing = hooks[existingIndex];
        if (existing.totalSpend === totalSpend) {
            console.warn(`‚ö†Ô∏è POTENTIAL DUPLICATE DETECTED: ${book} - ${hookName} - ${creativeId}`);
            console.warn(`   Both have EXACT same spend: $${existing.totalSpend.toFixed(2)}`);
            console.warn(`   Skipping to avoid double-counting.`);
            skippedCount++;
            continue; // Skip this row
        }
        
        // ADD to existing hook (consolidate)
        console.log(`üìà Consolidating with existing hook: ${book} - ${hookName}`);
        console.log(`   Before: Spend $${existing.totalSpend}, Revenue $${existing.totalRevenue}`);
        
        existing.totalSpend += totalSpend;
        existing.totalRevenue += totalRevenue;
        existing.purchases += purchases;
        existing.creativesCount += creativesCount;
        existing.overallROAS = existing.totalSpend > 0 ? existing.totalRevenue / existing.totalSpend : 0;
        
        // Update test date to the latest date (compare all dates properly)
        const existingTestDate = new Date(existing.testDate.split('/').reverse().join('-') + '-01');
        const newTestDate = new Date(testDate.split('/').reverse().join('-') + '-01');
        
        // Always update to the most recent date
        if (newTestDate > existingTestDate) {
            existing.testDate = testDate;
        }
        
        console.log(`   After:  Spend $${existing.totalSpend}, Revenue $${existing.totalRevenue}, ROAS ${existing.overallROAS.toFixed(2)}`);
        
        // Keep existing milestones (don't reset them)
        // They'll be recalculated by recordGroupMilestones below
    } else {
        // Create NEW hook
        const hookData = {
            book: book,
            hookName: hookName,
            testDate: testDate,
            totalSpend: totalSpend,
            totalRevenue: totalRevenue,
            purchases: purchases,
            creativesCount: creativesCount,
            creativeId: creativeId,
            overallROAS: totalSpend > 0 ? totalRevenue / totalSpend : 0,
            roasAt100: 0,
            roasAt300: 0,
            roasAt1000: 0,
            roasAt3000: 0
        };
        
        console.log(`‚úÖ Adding new hook: ${book} - ${hookName}`);
        hooks.push(hookData);
    }
    
    importedCount++;
    
    // Calculate NEW group totals after import
    const newGroupHooks = hooks.filter(h => h.book === book && h.hookName === hookName);
    const newGroupSpend = newGroupHooks.reduce((sum, h) => sum + h.totalSpend, 0);
    const newGroupRevenue = newGroupHooks.reduce((sum, h) => sum + h.totalRevenue, 0);
    const newGroupROAS = newGroupSpend > 0 ? newGroupRevenue / newGroupSpend : 0;
    
    // Trigger group milestone tracking
    const group = { book: book, hookName: hookName, creatives: newGroupHooks };
    recordGroupMilestones(group, previousGroupSpend, previousGroupROAS, newGroupSpend, newGroupROAS);
}
                    
                    // Save everything
                    saveToLocalAndCloud();
                    
                    // Refresh all views
                    updateBookOptions();
                    renderHooks();
                    renderBooks();
                    renderBooksAnalysis();
                    renderCreatives();
                    
                    // Show summary
const consolidatedMsg = consolidatedInFile > 0 ? 'üîó Consolidated: ' + consolidatedInFile + ' duplicate rows in file\n' : '';
const skippedMsg = skippedCount > 0 ? '‚ö†Ô∏è Skipped: ' + skippedCount + ' rows (missing data)\n' : '';
alert('Import Complete!\n\n‚úÖ Imported: ' + importedCount + ' hooks\n' + consolidatedMsg + skippedMsg + '\nüìä Total hooks now: ' + hooks.length);


                    
                    console.log(`‚úÖ Import summary: ${importedCount} imported, ${skippedCount} skipped`);
                    
                } catch (error) {
                    console.error('Import error:', error);
                    alert('Error importing file. Please check the format and try again.\n\nError: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input so the same file can be imported again
            event.target.value = '';
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                hooks = [];
                books = [];
                creativeNotes = {};
                localStorage.removeItem('adScalingHooks');
                localStorage.removeItem('adScalingBooks');
                localStorage.removeItem('adScalingCreativeNotes');
                localStorage.removeItem('groupMilestones');
                localStorage.removeItem('lastUpdated');
                
                // Clear cloud data too if signed in
                if (isSignedIn) {
                    saveToLocalAndCloud();
                }
                
                updateBookOptions();
                renderHooks();
                renderBooks();
                renderCreatives();
                clearForm();
                
                alert('All data cleared successfully!');
            }
        }

        // NEW FUNCTIONS FOR EXPANDABLE CREATIVE DETAILS
       function toggleCreativeDetails(groupIndex) {
    const toggle = document.getElementById(`toggle-${groupIndex}`);
    const creativeRows = document.querySelectorAll(`[id^="creative-${groupIndex}-"]`);
    
    if (toggle.textContent === '‚ñ∂') {
        toggle.textContent = '‚ñº';
        creativeRows.forEach(row => row.style.display = 'table-row');
    } else {
        toggle.textContent = '‚ñ∂';
        creativeRows.forEach(row => row.style.display = 'none');
    }
}

        function editHookGroup(key) {
            const [book, hookName] = key.split('||');
            const groupHooks = hooks.filter(h => h.book === book && h.hookName === hookName);
            
            // For now, edit the first hook in the group (we can enhance this later)
            const hookIndex = hooks.indexOf(groupHooks[0]);
            editHook(hookIndex);
        }

        function deleteHookGroup(key) {
            const [book, hookName] = key.split('||');
            const groupHooks = hooks.filter(h => h.book === book && h.hookName === hookName);
            
            if (confirm(`Are you sure you want to delete the hook "${hookName}" and all ${groupHooks.length} creative tests?`)) {
                // Remove all hooks in this group
                hooks = hooks.filter(h => !(h.book === book && h.hookName === hookName));
                saveToLocalAndCloud();
                renderHooks();
                renderCreatives();
            }
        }

        function archiveHook(index) {
            if (confirm('Archive this hook? It will be hidden but still count in statistics.')) {
                hooks[index].archived = true;
                hooks[index].archivedDate = new Date().toISOString();
                saveToLocalAndCloud();
                renderHooks();
                renderCreatives();
            }
        }

        function archiveHookGroup(key) {
            const [book, hookName] = key.split('||');
            const groupHooks = hooks.filter(h => h.book === book && h.hookName === hookName && !h.archived);
            
            if (confirm(`Archive the hook "${hookName}" and all ${groupHooks.length} creative tests? They'll be hidden but still count in statistics.`)) {
                // Mark all hooks in this group as archived
                hooks.forEach(hook => {
                    if (hook.book === book && hook.hookName === hookName) {
                        hook.archived = true;
                        hook.archivedDate = new Date().toISOString();
                    }
                });
                
                saveToLocalAndCloud();
                renderHooks();
                renderCreatives();
            }
        }

        function restoreHook(hookId) {
            if (confirm('Restore this hook from archive?')) {
                const hook = hooks.find(h => h.book === hookId.book && h.hookName === hookId.hookName && h.creativeId === hookId.creativeId);
                if (hook) {
                    delete hook.archived;
                    delete hook.archivedDate;
                    delete hook.archivedAsCreative;
                    saveToLocalAndCloud();
                    renderHooks();
                    renderArchive();
                    renderCreatives();
                }
            }
        }

        function permanentlyDeleteHook(hookId) {
            if (confirm('PERMANENTLY delete this hook? This cannot be undone and will affect all statistics!')) {
                const hookIndex = hooks.findIndex(h => 
                    h.book === hookId.book && 
                    h.hookName === hookId.hookName && 
                    h.creativeId === hookId.creativeId
                );
                if (hookIndex >= 0) {
                    hooks.splice(hookIndex, 1);
                    saveToLocalAndCloud();
                    renderArchive();
                    renderHooks();
                    renderCreatives();
                }
            }
        }

        function archiveCreative(creativeId) {
            if (confirm('Archive this creative? All hooks using it will be hidden but still count in statistics.')) {
                // Mark all hooks using this creative as archived
                hooks.forEach(hook => {
                    if (hook.creativeId === creativeId) {
                        hook.archived = true;
                        hook.archivedAsCreative = true;
                        hook.archivedDate = new Date().toISOString();
                    }
                });
                
                saveToLocalAndCloud();
                renderHooks();
                renderCreatives();
            }
        }

        function restoreCreative(creativeId) {
            if (confirm('Restore this creative from archive?')) {
                // Unmark all hooks using this creative
                hooks.forEach(hook => {
                    if (hook.creativeId === creativeId && hook.archivedAsCreative) {
                        delete hook.archived;
                        delete hook.archivedDate;
                        delete hook.archivedAsCreative;
                    }
                });
                
                saveToLocalAndCloud();
                renderHooks();
                renderCreatives();
                renderArchive();
            }
        }

        function permanentlyDeleteCreative(creativeId) {
            if (confirm('PERMANENTLY delete this creative and all its hooks? This cannot be undone and will affect all statistics!')) {
                // Remove all hooks using this creative
                hooks = hooks.filter(h => h.creativeId !== creativeId);
                saveToLocalAndCloud();
                renderArchive();
                renderHooks();
                renderCreatives();
            }
        }
        
        function toggleArchiveView(viewType) {
            const hooksView = document.getElementById('hooksArchiveView');
            const creativesView = document.getElementById('creativesArchiveView');
            
            if (viewType === 'hooks') {
                hooksView.style.display = 'block';
                creativesView.style.display = 'none';
                renderArchive();
            } else {
                hooksView.style.display = 'none';
                creativesView.style.display = 'block';
                renderCreativesArchive();
            }
        }
        
        function renderArchive() {
            const tbody = document.getElementById('archiveTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';

            const archivedHooks = hooks.filter(h => h.archived && !h.archivedAsCreative);

            if (archivedHooks.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 40px; color: #666;">No archived hooks yet</td></tr>';
                return;
            }

            archivedHooks.forEach((hook, index) => {
                const archivedDate = new Date(hook.archivedDate);
                const formattedDate = archivedDate.toLocaleDateString() + ' ' + archivedDate.toLocaleTimeString();
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${hook.book}</td>
                    <td>${hook.hookName}</td>
                    <td>${formattedDate}</td>
                    <td>$${hook.totalSpend.toFixed(2)}</td>
                    <td>$${hook.totalRevenue.toFixed(2)}</td>
                    <td><span class="${getRoasColorClass(hook.overallROAS)}">${hook.overallROAS.toFixed(2)}</span></td>
                    <td style="font-family: monospace; font-size: 11px;">${hook.creativeId}</td>
                    <td>
                        <button class="btn btn-success btn-sm" onclick='restoreHook(${JSON.stringify({book: hook.book, hookName: hook.hookName, creativeId: hook.creativeId})})'>‚Ü©Ô∏è Restore</button>
                        <button class="btn btn-danger btn-sm" onclick='permanentlyDeleteHook(${JSON.stringify({book: hook.book, hookName: hook.hookName, creativeId: hook.creativeId})})'>üóëÔ∏è Delete Forever</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function renderCreativesArchive() {
            const tbody = document.getElementById('creativesArchiveTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';

            const archivedCreativeHooks = hooks.filter(h => h.archived && h.archivedAsCreative);

            if (archivedCreativeHooks.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 40px; color: #666;">No archived creatives yet</td></tr>';
                return;
            }

            // Group by Creative ID
            const creativeGroups = {};
            archivedCreativeHooks.forEach(hook => {
                if (!creativeGroups[hook.creativeId]) {
                    creativeGroups[hook.creativeId] = {
                        creativeId: hook.creativeId,
                        hooks: [],
                        firstArchivedDate: hook.archivedDate
                    };
                }
                creativeGroups[hook.creativeId].hooks.push(hook);
                
                if (new Date(hook.archivedDate) < new Date(creativeGroups[hook.creativeId].firstArchivedDate)) {
                    creativeGroups[hook.creativeId].firstArchivedDate = hook.archivedDate;
                }
            });

            Object.keys(creativeGroups).forEach(creativeId => {
                const group = creativeGroups[creativeId];
                const totalSpend = group.hooks.reduce((sum, h) => sum + h.totalSpend, 0);
                const totalRevenue = group.hooks.reduce((sum, h) => sum + h.totalRevenue, 0);
                const overallROAS = totalSpend > 0 ? totalRevenue / totalSpend : 0;
                
                const archivedDate = new Date(group.firstArchivedDate);
                const formattedDate = archivedDate.toLocaleDateString() + ' ' + archivedDate.toLocaleTimeString();
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="font-family: monospace; font-size: 12px; word-break: break-all; white-space: normal;">${creativeId}</td>
                    <td>${group.hooks.length}</td>
                    <td>$${totalSpend.toFixed(2)}</td>
                    <td>$${totalRevenue.toFixed(2)}</td>
                    <td><span class="${getRoasColorClass(overallROAS)}">${overallROAS.toFixed(2)}</span></td>
                    <td>${formattedDate}</td>
                    <td>
                        <button class="btn btn-info btn-sm" onclick="viewCreativeDetails('${creativeId}')">üëÅÔ∏è View</button>
                        <button class="btn btn-success btn-sm" onclick="restoreCreative('${creativeId}')">‚Ü©Ô∏è Restore</button>
                        <button class="btn btn-danger btn-sm" onclick="permanentlyDeleteCreative('${creativeId}')">üóëÔ∏è Delete Forever</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // CREATIVE ID TRACKER FUNCTIONS
        function renderCreatives() {
            const tbody = document.getElementById('creativesTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';

            // Group ALL hooks by Creative ID (archived flag is just visual)
const creativeGroups = {};

hooks.forEach(hook => {
    if (!hook.creativeId) return;
    
    if (!creativeGroups[hook.creativeId]) {
        creativeGroups[hook.creativeId] = {
            creativeId: hook.creativeId,
            hooks: [],
            hasArchivedContent: false,
            allArchived: true
        };
    }
    
    creativeGroups[hook.creativeId].hooks.push(hook);
    
    if (hook.archived) {
        creativeGroups[hook.creativeId].hasArchivedContent = true;
    } else {
        creativeGroups[hook.creativeId].allArchived = false;
    }
});
            
            // Apply filters
            const searchTerm = document.getElementById('creativeSearch')?.value.toLowerCase() || '';
            const minRoas = parseFloat(document.getElementById('minRoasFilter')?.value) || 0;
            const minSpend = parseFloat(document.getElementById('minSpendFilter')?.value) || 0;

            Object.keys(creativeGroups).forEach(creativeId => {
                const group = creativeGroups[creativeId];
                
                // Calculate totals (including archived for complete picture)
                const totalSpend = group.hooks.reduce((sum, h) => sum + h.totalSpend, 0);
                const totalRevenue = group.hooks.reduce((sum, h) => sum + h.totalRevenue, 0);
                const overallROAS = totalSpend > 0 ? totalRevenue / totalSpend : 0;
                const hooksCount = group.hooks.length;
                const activeCount = group.hooks.filter(h => !h.archived).length;
                const archivedCount = group.hooks.filter(h => h.archived).length;
                
                // Apply filters
                if (searchTerm && !creativeId.toLowerCase().includes(searchTerm)) return;
                if (overallROAS < minRoas) return;
                if (totalSpend < minSpend) return;
                
                // Find best performing hook
                const bestHook = group.hooks.reduce((best, hook) => 
                    hook.overallROAS > (best?.overallROAS || 0) ? hook : best, null);

                const row = document.createElement('tr');
                
                // Different styling if completely archived vs has some archived content
let rowStyle = '';
let statusBadge = '';
if (group.allArchived) {
                    rowStyle = 'background: #f5f5f5; opacity: 0.8;';
                    statusBadge = '<span style="background: #9e9e9e; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">üì¶ ARCHIVED</span>';
                } else if (group.hasArchivedContent) {
                    statusBadge = '<span style="background: #ffc107; color: #000; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">‚ö†Ô∏è Has Archived</span>';
                }
                
                row.style.cssText = rowStyle;
                row.innerHTML = `
                    <td style="font-family: monospace; font-size: 12px; word-break: break-all; white-space: normal;">
                        ${creativeId}${statusBadge}
                    </td>
                    <td>$${totalSpend.toFixed(2)}</td>
                    <td>$${totalRevenue.toFixed(2)}</td>
                    <td><strong class="${getRoasColorClass(overallROAS)}">${overallROAS.toFixed(2)}</strong></td>
                    <td>
                        ${activeCount > 0 ? `<span style="color: #28a745;">‚úì ${activeCount} active</span>` : ''}
                        ${archivedCount > 0 ? `<br><span style="color: #666;">üì¶ ${archivedCount} archived</span>` : ''}
                    </td>
                    <td>${bestHook ? `${bestHook.hookName.substring(0, 30)}... (${bestHook.overallROAS.toFixed(2)})` : 'N/A'}</td>
                    <td>
                        <textarea class="creative-notes" placeholder="Add notes..." 
                                onchange="saveCreativeNote('${creativeId}', this.value)"
                                rows="2">${creativeNotes[creativeId] || ''}</textarea>
                    </td>
                    <td>
                        <button class="btn btn-info btn-sm" onclick="viewCreativeDetails('${creativeId}')">üëÅÔ∏è View</button>
                        ${!group.allArchived ? `<button class="btn btn-warning btn-sm" onclick="archiveCreative('${creativeId}')">üì¶ Archive</button>` : ''}
${group.allArchived ? `<button class="btn btn-success btn-sm" onclick="restoreCreative('${creativeId}')">‚Ü©Ô∏è Restore</button>` : ''}
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function filterCreatives() {
            renderCreatives();
        }

        function clearCreativeFilters() {
            document.getElementById('creativeSearch').value = '';
            document.getElementById('minRoasFilter').value = '';
            document.getElementById('minSpendFilter').value = '';
            renderCreatives();
        }

        function saveCreativeNote(creativeId, note) {
            creativeNotes[creativeId] = note;
            saveToLocalAndCloud();
        }

        function getRoasColorClass(roas) {
            if (roas < 0.6) return 'roas-poor';
            if (roas < 0.8) return 'roas-okay';
            return 'roas-good';
        }

        function viewCreativeDetails(creativeId) {
            // Get all hooks for this creative (active and archived)
            const allHooks = hooks.filter(h => h.creativeId === creativeId);
            const activeHooks = allHooks.filter(h => !h.archived);
            const archivedHooks = allHooks.filter(h => h.archived);
            
            let details = `Creative ID: ${creativeId}\n\n`;
            details += `Total hooks using this creative: ${allHooks.length}\n`;
            details += `‚îú‚îÄ Active: ${activeHooks.length}\n`;
            details += `‚îî‚îÄ Archived: ${archivedHooks.length}\n\n`;
            
            if (activeHooks.length > 0) {
                details += `ACTIVE HOOKS:\n`;
                details += `${'‚îÄ'.repeat(50)}\n`;
                activeHooks.forEach(hook => {
                    details += `‚Ä¢ ${hook.book} - ${hook.hookName}\n`;
                    details += `  Spend: $${hook.totalSpend.toFixed(2)}, Revenue: $${hook.totalRevenue.toFixed(2)}, ROAS: ${hook.overallROAS.toFixed(2)}\n\n`;
                });
            }
            
            if (archivedHooks.length > 0) {
                details += `\nARCHIVED HOOKS:\n`;
                details += `${'‚îÄ'.repeat(50)}\n`;
                archivedHooks.forEach(hook => {
                    details += `üì¶ ${hook.book} - ${hook.hookName}\n`;
                    details += `  Spend: $${hook.totalSpend.toFixed(2)}, Revenue: $${hook.totalRevenue.toFixed(2)}, ROAS: ${hook.overallROAS.toFixed(2)}\n\n`;
                });
            }
            
            alert(details);
        }

        // UPDATE SWITCH TAB TO INCLUDE CREATIVES
        function switchTab(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Remove active class from all tabs
    document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Show selected tab content
    document.getElementById(tabName + 'Tab').classList.add('active');
    
    // Add active class to clicked tab
    event.target.classList.add('active');
    
    // Refresh data when switching tabs
if (tabName === 'books') {
    renderBooksAnalysis();
} else if (tabName === 'creatives') {
    renderCreatives();
} else if (tabName === 'archive') {
    renderArchive();
}
}
    </script>
        </div>
        <!-- End of mainApp -->
    </div>
</body>
</html>
